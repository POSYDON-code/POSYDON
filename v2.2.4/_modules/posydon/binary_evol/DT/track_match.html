

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>posydon.binary_evol.DT.track_match &mdash; posydon 2.2.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=9430f4b5" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=4e6cfea6"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html">
            
              <img src="../../../../_static/posydon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction-acknowledgements/intro.html">Introduction, Objectives, and Scope</a></li>
<li class="toctree-l1"><a class="reference external" href="https://posydon.org/team.html">Collaborative Team</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ui.adsabs.harvard.edu/public-libraries/ZZsD9bzLTzWnLV3hwyJxbA">Publications</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting-started/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting-started/installation-guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting-started/first-grids.html">Quick Start: Examining the MESA Grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting-started/first-population.html">Quick Start: Your First Population</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials and Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials-examples/population-synthesis/binary-pop-syn.html">Binary-Star Population Synthesis with POSYDON</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials-examples/generating-datasets/generating-datasets.html">Crafting the Core Datasets for POSYDON</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials-examples/MESA-grids/running-grids.html">Architecting MESA Simulation Grids with POSYDON</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">POSYDON school material</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/POSYDON-code/POSYDON-2025-School-Labs">POSYDON School 2025</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">In-Depth Components Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../components-overview/mesa-grids.html">MESA Grids API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../components-overview/processing-pipeline.html">Processing Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../components-overview/machine-learning-components.html">Machine Learning Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../components-overview/stellar-binary-simulation.html">Stellar &amp; Binary-star Simulation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_reference/posydon.html">posydon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_reference/bin.html">executables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Releases and Datasets</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/POSYDON-code/POSYDON/releases">Releases</a></li>
<li class="toctree-l1"><a class="reference external" href="https://zenodo.org/communities/posydon/">Datasets</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Support and Contact</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contact-support/contact-information.html">Contact Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../troubleshooting-faqs/installation-issues.html">Common Installation Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../troubleshooting-faqs/code-questions.html">Code Usage Questions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/POSYDON-code/POSYDON/issues/new/choose">Report an Issue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/how-to-contribute.html">How To Contribute</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">posydon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">posydon.binary_evol.DT.track_match</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for posydon.binary_evol.DT.track_match</h1><div class="highlight"><pre>
<span></span><span class="n">__authors__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Devina Misra &lt;devina.misra@unige.ch&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Zepei Xing &lt;Zepei.Xing@unige.ch&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Emmanouil Zapartas &lt;ezapartas@gmail.com&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Nam Tran &lt;tranhn03@gmail.com&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Simone Bavera &lt;Simone.Bavera@unige.ch&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Konstantinos Kovlakas &lt;Konstantinos.Kovlakas@unige.ch&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Kyle Akira Rocha &lt;kylerocha2024@u.northwestern.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Jeffrey Andrews &lt;jeffrey.andrews@northwestern.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Camille Liotine &lt;cliotine@u.northwestern.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Seth Gossage &lt;seth.gossage@northwestern.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Max Briel &lt;max.briel@gmail.com&gt;&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">root</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">posydon.utils.constants</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">const</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.binary_evol.DT.key_library</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_PROFILE_KEYS</span><span class="p">,</span>
    <span class="n">DEFAULT_TRANSLATED_KEYS</span><span class="p">,</span>
    <span class="n">KEYS_POSITIVE</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.binary_evol.flow_chart</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">STAR_STATES_CO</span><span class="p">,</span>
    <span class="n">STAR_STATES_FOR_HMS_MATCHING</span><span class="p">,</span>
    <span class="n">STAR_STATES_H_RICH</span><span class="p">,</span>
    <span class="n">STAR_STATES_HE_RICH</span><span class="p">,</span>
    <span class="n">STAR_STATES_FOR_Hestar_MATCHING</span><span class="p">,</span>
    <span class="n">STAR_STATES_FOR_postHeMS_MATCHING</span><span class="p">,</span>
    <span class="n">STAR_STATES_FOR_postMS_MATCHING</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">PATH_TO_POSYDON_DATA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.interpolation.data_scaling</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.interpolation.interpolation</span><span class="w"> </span><span class="kn">import</span> <span class="n">GRIDInterpolator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.utils.common_functions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">convert_metallicity_to_string</span><span class="p">,</span>
    <span class="n">set_binary_to_failed</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.utils.interpolators</span><span class="w"> </span><span class="kn">import</span> <span class="n">SingleStarInterpolator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.utils.posydonerror</span><span class="w"> </span><span class="kn">import</span> <span class="n">MatchingError</span><span class="p">,</span> <span class="n">NumericalError</span><span class="p">,</span> <span class="n">POSYDONError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">posydon.utils.posydonwarning</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pwarn</span>

<span class="n">MATCHING_WITH_RELATIVE_DIFFERENCE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;center_he4&quot;</span><span class="p">]</span>


<span class="n">val_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">,</span> <span class="s2">&quot;center_h1&quot;</span><span class="p">,</span> <span class="s2">&quot;surface_h1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_he4&quot;</span><span class="p">,</span> <span class="s2">&quot;surface_he4&quot;</span><span class="p">,</span>
                <span class="s2">&quot;center_c12&quot;</span><span class="p">]</span>
<span class="n">str_fmts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{:&gt;14}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{:&gt;9}</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;</span><span class="si">{:&gt;9}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{:&gt;9}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="s2">&quot;</span><span class="si">{:&gt;10}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="s2">&quot;</span><span class="si">{:&gt;12}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{:&gt;10}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="s2">&quot;</span><span class="si">{:&gt;11}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="s2">&quot;</span><span class="si">{:&gt;10}</span><span class="s2">&quot;</span><span class="p">]</span>
<span class="n">row_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">str_fmts</span><span class="p">)</span>
<span class="n">DIVIDER_STR</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">row_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">str_fmts</span><span class="p">)))</span>
<span class="c1"># MAJOR.MINOR version of imported scipy package</span>
<span class="n">SCIPY_VER</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]))</span>

<div class="viewcode-block" id="TrackMatcher">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TrackMatcher</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class contains the functionality to match binary star components</span>
<span class="sd">    to single star models for detached evolution. Typically, this is so that</span>
<span class="sd">    the binary star can continue evolving in a detached (non-interacting)</span>
<span class="sd">    state.</span>

<span class="sd">        Several matching methods may be used, and metrics (physical</span>
<span class="sd">    quantities) that are used to determine the quality of the match may be</span>
<span class="sd">    customized. By default, the metrics are as follows:</span>

<span class="sd">      Initial stellar matching metrics</span>
<span class="sd">      ========================================</span>

<span class="sd">      MS:          mass,                      center X, radius, He core mass</span>
<span class="sd">      post-MS:     mass,                      center Y, radius, He core mass</span>
<span class="sd">      stripped He: He core mass (mass proxy), center Y, radius</span>

<span class="sd">        If an initial match can not be found, alternative sets of metrics are</span>
<span class="sd">    used. For example, stars after mass transfer could swell up so that log_R</span>
<span class="sd">    is not appropriate for matching. Lists for HMS and postMS stars drop</span>
<span class="sd">    radius as a matching metric in these alternatives:</span>

<span class="sd">      Alternative stellar matching metrics</span>
<span class="sd">      ========================================</span>

<span class="sd">      MS:          total mass,                      center X, He core mass</span>
<span class="sd">      post-MS:     total mass,                      center Y, He core mass</span>
<span class="sd">      stripped He: He core mass (total mass proxy), center Y, radius</span>

<span class="sd">    The available matching methods are:</span>

<span class="sd">        &quot;root&quot;:     This method invokes a modified Powell&#39;s method to</span>
<span class="sd">                    minimize the difference between stellar mass and</span>
<span class="sd">                    central hydrogen abundance (if the star is H-rich),</span>
<span class="sd">                    or He core mass (if the star is He-rich). The function</span>
<span class="sd">                    used is scipy.optimize.root with the &#39;hybr&#39; method.</span>

<span class="sd">        &quot;minimize&quot;: This method minimizes the Euclidean distance between</span>
<span class="sd">                    several matching metrics (the same mentioned above).</span>
<span class="sd">                    This is the default matching method.</span>

<span class="sd">        Stellar tracks in either the H- or He-rich single star grids will</span>
<span class="sd">    be searched until a match is found within an acceptable tolerance. If</span>
<span class="sd">    no match can be found, the binary star will be marked as a failed</span>
<span class="sd">    binary as its evolution can progress no further.</span>

<span class="sd">        If an acceptable match is found, then we were able to find a star</span>
<span class="sd">    within the single star grids that suitably represents the given star(s)</span>
<span class="sd">    at their current point in evolution. This class will return interpolator</span>
<span class="sd">    objects that may be used to calculate quantities along the matched stellar</span>
<span class="sd">    track so that the binary&#39;s stars may be evolved further, such as through</span>
<span class="sd">    detached evolution.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    KEYS : list[str]</span>
<span class="sd">        Contains valid keywords which are used to extract quantities from</span>
<span class="sd">        the grids.</span>

<span class="sd">    KEYS_POSITIVE : list[str]</span>
<span class="sd">        Keys in this list are forced to be positive or else 0 by the</span>
<span class="sd">        posydon.utils.SingleStarInterpolator class following interpolation</span>
<span class="sd">        of the associated quantity.</span>

<span class="sd">    path : str</span>
<span class="sd">        Path to the directory that contains POSYDON data HDF5 files. Defaults</span>
<span class="sd">        to the PATH_TO_POSYDON_DATA environment variable.</span>

<span class="sd">    metallicity : str</span>
<span class="sd">        The metallicity of the grid. This should be one of the eight</span>
<span class="sd">        supported metallicities, stored as a string (e.g.,</span>
<span class="sd">        1e+00 as &quot;1e+00_Zsun&quot;).</span>

<span class="sd">    matching_method : str</span>
<span class="sd">        Method to find the best match between a star from a previous step and a</span>
<span class="sd">        point in a single star evolution track. Options:</span>

<span class="sd">            &quot;root&quot;: Tries to find a root of two matching quantities. It is</span>
<span class="sd">                    possible to not find one, causing the evolution to fail.</span>

<span class="sd">            &quot;minimize&quot;: Minimizes the sum of squares of differences of</span>
<span class="sd">                        various quantities between the previous evolution step</span>
<span class="sd">                        and a stellar evolution track.</span>

<span class="sd">    root_keys : numpy.ndarray</span>
<span class="sd">        An array of keys corresponding to possible matching metrics. These</span>
<span class="sd">        keys should exist as MESA history data column names. In practice,</span>
<span class="sd">        we match using only a subset of these.</span>

<span class="sd">    rootm : numpy.ndarray</span>
<span class="sd">        A 3D matrix to hold roots with dimensions</span>

<span class="sd">            DIM = [N(initial_masses),</span>
<span class="sd">                   N(max_evolution_track_length),</span>
<span class="sd">                   N(matching_metrics)]</span>

<span class="sd">        Structured to hold the matching metrics along the entire evolution</span>
<span class="sd">        track of each stellar evolution track of a given initial mass in</span>
<span class="sd">        a single star grid. Assigned after loading a grid and before</span>
<span class="sd">        storing matching metrics.</span>

<span class="sd">    grid_name_Hrich : str</span>
<span class="sd">        Name of the single star H-rich grid h5 file,</span>
<span class="sd">        including its parent directory. This is set to</span>
<span class="sd">        (w/ Z = 1e+00, for example):</span>

<span class="sd">            grid_name_Hrich = &#39;single_HMS/1e+00_Zsun.h5&#39;</span>

<span class="sd">        by default if not specified.</span>

<span class="sd">    grid_name_strippedHe : str</span>
<span class="sd">        Name of the single star He-rich grid h5 file. This is</span>
<span class="sd">        set to (w/ Z = 1e+00, for example):</span>

<span class="sd">            grid_name_strippedHe = &#39;single_HeMS/1e+00_Zsun.h5&#39;</span>

<span class="sd">        by default if not specified.</span>

<span class="sd">    grid_Hrich : GRIDInterpolator object</span>
<span class="sd">        Object to interpolate between the time-series (i.e., along the</span>
<span class="sd">        evolutionary track) in the H-rich single star h5 grid.</span>

<span class="sd">    grid_strippedHe : GRIDInterpolator object</span>
<span class="sd">        Object to interpolate between the time-series (i.e., along the</span>
<span class="sd">        evolutionary track) in the He-rich single star h5 grid.</span>

<span class="sd">    initial_mass : list[float]</span>
<span class="sd">            Contains the initial masses of the stars in the single star</span>
<span class="sd">            grid in which we are searching for a match. Assigned after</span>
<span class="sd">            loading a grid to match to.</span>

<span class="sd">    list_for_matching_HMS : list</span>
<span class="sd">        A list of mixed type that specifies properties of the matching</span>
<span class="sd">        process for HMS stars. This list has the following structure:</span>

<span class="sd">            list_for_matching = [[matching attr. names], [rescale_factors],</span>
<span class="sd">                                 [scaling method], [mass_bnds], [age_bnds]]</span>

<span class="sd">    list_for_matching_postMS : list</span>
<span class="sd">        A list of mixed type that specifies properties of the matching</span>
<span class="sd">        process for postMS stars. This list has the following structure:</span>

<span class="sd">            list_for_matching = [[matching attr. names], [rescale_factors],</span>
<span class="sd">                                 [scaling method], [mass_bnds], [age_bnds]]</span>

<span class="sd">    list_for_matching_HeStar : list</span>
<span class="sd">        A list of mixed type that specifies properties of the matching</span>
<span class="sd">        process for He stars. This list has the following structure:</span>

<span class="sd">            list_for_matching = [[matching attr. names], [rescale_factors],</span>
<span class="sd">                                 [scaling method], [mass_bnds], [age_bnds]]</span>

<span class="sd">    stored_scalers : dict</span>
<span class="sd">        Mapping a combination of (key, htrack, scaling_method) to a</span>
<span class="sd">        pre-trained DataScaler instance.</span>

<span class="sd">    final_keys : tuple</span>
<span class="sd">        Contains keys for final value interpolation.</span>

<span class="sd">    profile_keys : tuple</span>
<span class="sd">        Contains keys for profile interpolation.</span>

<span class="sd">    matching_tolerance : float</span>
<span class="sd">        When using the &quot;minimize&quot; matching method, a computed square</span>
<span class="sd">        Euclidean distance between the pre-match and post-match values</span>
<span class="sd">        less than this must be achieved for a successful match.</span>

<span class="sd">    matching_tolerance_hard : float</span>
<span class="sd">        When using the &quot;minimize&quot; matching method, a computed square</span>
<span class="sd">        Euclidean distance between the pre-match and post-match values</span>
<span class="sd">        less than at most this must be achieved for a successful match.</span>
<span class="sd">        This tolerance is checked after all else fails, as a last attempt</span>
<span class="sd">        to find a solution.</span>

<span class="sd">    record_matching : bool</span>
<span class="sd">        True if we want to append matched quantities to the binary history.</span>

<span class="sd">    verbose : bool</span>
<span class="sd">        True if we want to print stuff.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    A matching between the properties of the star, and the h5 tracks are</span>
<span class="sd">    required. In the &quot;root&quot; solver matching_method, if the root solver fails</span>
<span class="sd">    then the evolution will immediately end and the binary state will be</span>
<span class="sd">    tagged with &quot;Root solver failed&quot;. In the &quot;minimize&quot; matching_method, we</span>
<span class="sd">    minimize the sum of squares of differences of various quantities between</span>
<span class="sd">    the previous step and the h5 track.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">grid_name_Hrich</span><span class="p">,</span>
            <span class="n">grid_name_strippedHe</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="n">PATH_TO_POSYDON_DATA</span><span class="p">,</span>
            <span class="n">metallicity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">matching_method</span><span class="o">=</span><span class="s2">&quot;minimize&quot;</span><span class="p">,</span>
            <span class="n">matching_tolerance</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
            <span class="n">matching_tolerance_hard</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span>
            <span class="n">list_for_matching_HMS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">list_for_matching_postMS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">list_for_matching_HeStar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">list_for_matching_postHeMS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">record_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>

        <span class="c1"># MESA history column names used as matching metrics</span>
        <span class="c1"># TODO: should this be singlestar.STARPROPERTIES? An</span>
        <span class="c1">#       error is thrown when (possibly user defined)</span>
        <span class="c1">#       matching metrics don&#39;t exist in this array.</span>
        <span class="c1">#       That&#39;s not very flexible...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;age&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mass&quot;</span><span class="p">,</span>
                <span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span>
                <span class="s2">&quot;center_h1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;center_he4&quot;</span><span class="p">,</span>
                <span class="s2">&quot;surface_he4&quot;</span><span class="p">,</span>
                <span class="s2">&quot;surface_h1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;log_R&quot;</span><span class="p">,</span>
                <span class="s2">&quot;center_c12&quot;</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># =====================================================================</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metallicity</span> <span class="o">=</span> <span class="n">convert_metallicity_to_string</span><span class="p">(</span><span class="n">metallicity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matching_method</span> <span class="o">=</span> <span class="n">matching_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance</span> <span class="o">=</span> <span class="n">matching_tolerance</span> <span class="c1"># DEFAULT: 1e-2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span> <span class="o">=</span> <span class="n">matching_tolerance_hard</span> <span class="c1"># DEFAULT: 1e-1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initial_mass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS</span> <span class="o">=</span> <span class="n">list_for_matching_HMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS</span> <span class="o">=</span> <span class="n">list_for_matching_postMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar</span> <span class="o">=</span> <span class="n">list_for_matching_HeStar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS</span> <span class="o">=</span> <span class="n">list_for_matching_postHeMS</span>

        <span class="c1"># mapping a combination of (key, htrack, method) to a pre-trained</span>
        <span class="c1"># DataScaler instance, created the first time it is requested</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored_scalers</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># these are the KEYS read from POSYDON h5 grid files (after translating</span>
        <span class="c1"># them to the appropriate columns)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KEYS</span> <span class="o">=</span> <span class="n">DEFAULT_TRANSLATED_KEYS</span> <span class="c1">#KEYS #DEFAULT_TRANSLATED_KEYS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">KEYS_POSITIVE</span> <span class="o">=</span> <span class="n">KEYS_POSITIVE</span>

        <span class="c1"># keys for the final value interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;avg_c_in_c_core_at_He_depletion&#39;</span><span class="p">,</span>
            <span class="s1">&#39;co_core_mass_at_He_depletion&#39;</span><span class="p">,</span>
            <span class="s1">&#39;m_core_CE_1cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;m_core_CE_10cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;m_core_CE_30cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;m_core_CE_pure_He_star_10cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;r_core_CE_1cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;r_core_CE_10cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;r_core_CE_30cent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;r_core_CE_pure_He_star_10cent&#39;</span>
        <span class="p">)</span>

        <span class="c1"># keys for the star profile interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_keys</span> <span class="o">=</span> <span class="n">DEFAULT_PROFILE_KEYS</span>

        <span class="c1"># should grids just get passed to this?</span>
        <span class="k">if</span> <span class="n">grid_name_Hrich</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_name_Hrich</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;single_HMS&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">metallicity</span><span class="o">+</span><span class="s1">&#39;_Zsun.h5&#39;</span><span class="p">)</span>
        <span class="n">grid_path_Hrich</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid_name_Hrich</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span> <span class="o">=</span> <span class="n">GRIDInterpolator</span><span class="p">(</span><span class="n">grid_path_Hrich</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grid_name_strippedHe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_name_strippedHe</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;single_HeMS&#39;</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">metallicity</span><span class="o">+</span><span class="s1">&#39;_Zsun.h5&#39;</span><span class="p">)</span>
        <span class="n">grid_path_strippedHe</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid_name_strippedHe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span> <span class="o">=</span> <span class="n">GRIDInterpolator</span><span class="p">(</span><span class="n">grid_path_strippedHe</span><span class="p">)</span>

        <span class="c1"># =====================================================================</span>

        <span class="c1"># Initialize the matching lists:</span>

        <span class="c1"># min/max ranges of initial masses for each grid</span>
        <span class="n">m_min_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">)</span>
        <span class="n">m_max_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">)</span>
        <span class="n">m_min_He</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">)</span>
        <span class="n">m_max_He</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">)</span>

        <span class="c1"># min/max ranges of ages for each grid</span>
        <span class="n">t_min_H</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">t_max_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">t_min_He</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">t_max_He</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Stellar parameter matching metrics</span>
        <span class="c1"># ========================================</span>
        <span class="c1"># At first, we try to match based on...</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_h1&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">,</span> <span class="s2">&quot;he_core_mass&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;log_min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m_min_H</span><span class="p">,</span> <span class="n">m_max_H</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_H</span><span class="p">,</span> <span class="n">t_max_H</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_he4&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">,</span> <span class="s2">&quot;he_core_mass&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;log_min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m_min_H</span><span class="p">,</span> <span class="n">m_max_H</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_H</span><span class="p">,</span> <span class="n">t_max_H</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_he4&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m_min_He</span><span class="p">,</span> <span class="n">m_max_He</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_He</span><span class="p">,</span> <span class="n">t_max_He</span><span class="p">]</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                <span class="p">[</span><span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m_min_He</span><span class="p">,</span> <span class="n">m_max_He</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_He</span><span class="p">,</span> <span class="n">t_max_He</span><span class="p">]</span>
            <span class="p">]</span>

        <span class="c1"># Stellar parameter lists for alternative matching metrics</span>
        <span class="c1"># These are used in the event that an initial match can not be found</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS_alternative</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_h1&quot;</span><span class="p">,</span> <span class="s2">&quot;he_core_mass&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;log_min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">m_min_H</span><span class="p">,</span> <span class="n">m_max_H</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_H</span><span class="p">,</span> <span class="n">t_max_H</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS_alternative</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_h1&quot;</span><span class="p">,</span> <span class="s2">&quot;he_core_mass&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;log_min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">m_min_H</span><span class="p">,</span> <span class="n">m_max_H</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_H</span><span class="p">,</span> <span class="n">t_max_H</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar_alternative</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;center_he4&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">m_min_He</span><span class="p">,</span> <span class="n">m_max_He</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_He</span><span class="p">,</span> <span class="n">t_max_He</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS_alternative</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;log_R&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;min_max&quot;</span><span class="p">,</span> <span class="s2">&quot;min_max&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">m_min_He</span><span class="p">,</span> <span class="n">m_max_He</span><span class="p">],</span> <span class="p">[</span><span class="n">t_min_He</span><span class="p">,</span> <span class="n">t_max_He</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">record_matching</span> <span class="o">=</span> <span class="n">record_matching</span>

<div class="viewcode-block" id="TrackMatcher.get_root0">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.get_root0">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_root0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">,</span> <span class="n">attr_vals</span><span class="p">,</span> <span class="n">htrack</span><span class="p">,</span> <span class="n">rescale_facs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the stellar evolution track in the single star grid with values</span>
<span class="sd">        closest to the requested ones. This calculates the difference in</span>
<span class="sd">        stellar properties between a given track and those in the single star</span>
<span class="sd">        grids. It then returns the mass of and age along the track where the</span>
<span class="sd">        minimum difference occurs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr_names : list[str]</span>
<span class="sd">            Contains the keys of the requested specific quantities that will</span>
<span class="sd">            be matched in the single star track.</span>

<span class="sd">        attr_vals : list[float]</span>
<span class="sd">            Contains the latest values (from a previous POSYDON step) of the</span>
<span class="sd">            quantities of &quot;keys&quot; in the POSYDON SingleStar object. This should</span>
<span class="sd">            be the same length as &quot;keys&quot;.</span>

<span class="sd">        htrack : bool</span>
<span class="sd">            Set True to search the single star H-rich grids, or False to</span>
<span class="sd">            search the He-rich grids.</span>

<span class="sd">        rescale_facs : list[float]</span>
<span class="sd">            Contains normalization factors to be divided for rescaling</span>
<span class="sd">            attribute values. This should be the same length as attr_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m0 : float</span>
<span class="sd">            Initial mass (in solar units) of the minimum diff model for initial</span>
<span class="sd">            guess.</span>

<span class="sd">        t0 : float</span>
<span class="sd">            Age (in years) of the minimum diff model for initial guess.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set which grid to search based on htrack condition</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span> <span class="k">if</span> <span class="n">htrack</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>

        <span class="c1"># initial masses within grid (defined but never used? used in scale())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_mass</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span>

        <span class="c1"># search across all initial masses and get max track length</span>
        <span class="n">max_track_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">mass</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">:</span>
            <span class="n">track_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="n">mass</span><span class="p">))</span>
            <span class="n">max_track_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_track_length</span><span class="p">,</span> <span class="n">track_length</span><span class="p">)</span>

        <span class="c1"># intialize root matrix</span>
        <span class="c1"># (DIM = [N(Mi), N(max_track_length), N(root_keys)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">),</span>
                                    <span class="n">max_track_length</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="p">)))</span>

        <span class="c1"># for each mass, get matching metrics and store in matrix</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mass</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="p">):</span>
                <span class="n">track</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mass</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="p">),</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">track</span>

        <span class="c1"># rescaling factors</span>
        <span class="k">if</span> <span class="n">rescale_facs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rescale_facs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">attr_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rescale_facs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">rescale_facs</span><span class="p">)</span>

        <span class="n">star_attr_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">attr_vals</span><span class="p">)</span>

        <span class="c1"># indices where given attribute names match available matching metrics</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">attr_names</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Slice out just the matching metric data for all stellar tracks</span>
        <span class="c1"># grid_attr_vals now has shape</span>
        <span class="c1"># (N(Mi), N(max_track_len), N(matching_metrics))</span>
        <span class="n">grid_attr_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootm</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">]</span>

        <span class="c1"># For all stellar tracks in grid:</span>
        <span class="c1"># Take difference btwn. grid track and given star values...</span>
        <span class="n">grid_diff</span> <span class="o">=</span> <span class="n">grid_attr_vals</span> <span class="o">-</span> <span class="n">star_attr_vals</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># rescale...</span>
        <span class="n">grid_diff</span> <span class="o">/=</span> <span class="n">rescale_facs</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># and take (Frobenius) norm.</span>
        <span class="n">grid_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grid_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># indices where minimum difference occurs (i.e., of</span>
        <span class="c1"># closest matching track). This contains the indices at</span>
        <span class="c1"># position of (min diff mass, min diff age)</span>
        <span class="n">min_diff_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">grid_diff</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span>
                                         <span class="n">grid_attr_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">mass_i</span> <span class="o">=</span> <span class="n">min_diff_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">age_i</span> <span class="o">=</span> <span class="n">min_diff_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># time and initial mass corresp. to track w/ minimum difference</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="p">[</span><span class="n">mass_i</span><span class="p">]</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootm</span><span class="p">[</span><span class="n">mass_i</span><span class="p">][</span><span class="n">age_i</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="s2">&quot;age&quot;</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">m0</span><span class="p">,</span> <span class="n">t0</span></div>


<div class="viewcode-block" id="TrackMatcher.get_track_val">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.get_track_val">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_track_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">htrack</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            Return a single value of a stellar property from the</span>
<span class="sd">        interpolated time-series along a requested stellar track</span>
<span class="sd">        of mass `m0` at an age of `t`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            Keyword of the desired quantity.</span>

<span class="sd">        m0 : float</span>
<span class="sd">            The initial mass of the desired stellar track.</span>

<span class="sd">        t : float</span>
<span class="sd">            The desired age along the stellar track.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val : float</span>
<span class="sd">            The value of the desired quantity from a stellar track of</span>
<span class="sd">            initial mass `m0` at the time `t`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># htrack as a boolean determines whether H or He grid is used</span>
        <span class="k">if</span> <span class="n">htrack</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="n">m0</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">m0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mf">1e99</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">1e99</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">i_bad</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_bad</span><span class="p">):</span>
                <span class="n">i_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i_bad</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">i_bad</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="TrackMatcher.scale">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">htrack</span><span class="p">,</span> <span class="n">scaler_method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            Normalize quantities in the single star grids to (0,1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr_name : str</span>
<span class="sd">            Keyword of the requested quantity.</span>

<span class="sd">        htrack : bool</span>
<span class="sd">            A boolean that specifies whether the star would be found in the</span>
<span class="sd">            hydrogen rich single star grid or not (in which case it is</span>
<span class="sd">            matched to the helium rich single star grid).</span>

<span class="sd">        scaler_method : str</span>
<span class="sd">            Scaling method in the DataScaler class. See</span>
<span class="sd">            posydon.interpolation.data_scaling.DataScaler().fit() for more</span>
<span class="sd">            details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scaler : DataScaler object</span>
<span class="sd">            This is a DataScaler object, trained to rescale the requested</span>
<span class="sd">            attribute to the range (0, 1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: why this self.grid? Why not local variable. Should this affect</span>
        <span class="c1"># the whole detached_step instance?</span>

        <span class="c1"># collect all options for the scaler</span>
        <span class="n">scaler_options</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">htrack</span><span class="p">,</span> <span class="n">scaler_method</span><span class="p">)</span>

        <span class="c1"># find if the scaler has already been fitted and return it if so...</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_scalers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">scaler_options</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scaler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scaler</span>

        <span class="c1"># ...if not, fit a new scaler, and store it for later use</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span> <span class="k">if</span> <span class="n">htrack</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_mass</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span>
        <span class="n">all_attributes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">mass</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_mass</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">mass</span><span class="p">):</span>
                <span class="n">all_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">all_attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_attributes</span><span class="p">)</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">DataScaler</span><span class="p">()</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">all_attributes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">scaler_method</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored_scalers</span><span class="p">[</span><span class="n">scaler_options</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span>

        <span class="k">return</span> <span class="n">scaler</span></div>


<div class="viewcode-block" id="TrackMatcher.match_to_single_star">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.match_to_single_star">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match_to_single_star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the track in the grid that matches the time and mass of a star,</span>
<span class="sd">        that has typically undergone prior binary star evolution. A match is</span>
<span class="sd">        made according to a given algorithm that minimizes the difference</span>
<span class="sd">        amongst several physical properties, e.g., mass, central hydrogen</span>
<span class="sd">        abundance, radius, and core helium mass, depending on the type of star</span>
<span class="sd">        being matched. However, these properties may also be customized by the</span>
<span class="sd">        user.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            A single star object that contains the star&#39;s properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        match_m0 : float</span>
<span class="sd">            Initial mass (in solar units) of the matched model.</span>

<span class="sd">        match_t0 : float</span>
<span class="sd">            Age (in years) of the matched model.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        EvolutionWarning</span>
<span class="sd">            If attempting to match an He-star with an H-rich grid or post-MS</span>
<span class="sd">            star with a stripped-He grid. This can happen if an initial</span>
<span class="sd">            matching attempt fails; alternative grids are checked for a match</span>
<span class="sd">            in such cases.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If a matching parameter does not exist in the single star</span>
<span class="sd">            grid options</span>

<span class="sd">        NumericalError</span>
<span class="sd">            If SciPy numerical differentiation occured outside boundary</span>
<span class="sd">            while matching to single star track.</span>

<span class="sd">        MatchingError</span>
<span class="sd">            If the initial mass to be matched is out of the single star grid</span>
<span class="sd">            range, thereby preventing a possible match.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># setting whether to match to track from H-rich</span>
        <span class="c1"># or stripped He star grid</span>
        <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>

        <span class="n">get_root0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_root0</span>
        <span class="n">get_track_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_track_val</span>

        <span class="n">match_vals</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matching process started in detached step for &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2"> star with matching &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;method = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_method</span> <span class="o">==</span> <span class="s2">&quot;minimize&quot;</span><span class="p">:</span>
                  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matching_tolerance = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;matching_tolerance_hard = &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># matching via root method (ultimately modified Powell&#39;s method)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_method</span> <span class="o">==</span> <span class="s2">&quot;root&quot;</span><span class="p">:</span>
            <span class="n">match_vals</span><span class="p">,</span> <span class="n">best_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_through_root</span><span class="p">(</span><span class="n">star</span><span class="p">,</span>
                                                            <span class="n">get_root0</span><span class="p">,</span>
                                                            <span class="n">get_track_val</span><span class="p">)</span>

        <span class="c1"># matching using minimize method (Newton or Powell method)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_method</span> <span class="o">==</span> <span class="s2">&quot;minimize&quot;</span><span class="p">:</span>
            <span class="n">match_vals</span><span class="p">,</span> <span class="n">best_sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_through_minimize</span><span class="p">(</span><span class="n">star</span><span class="p">,</span>
                                                                <span class="n">get_root0</span><span class="p">,</span>
                                                                <span class="n">get_track_val</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># successful match</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">match_vals</span><span class="p">)):</span>

                <span class="n">getv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">get_track_val</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span><span class="p">,</span> <span class="o">*</span><span class="n">best_sol</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">sol_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">getv</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">val_names</span><span class="p">[</span><span class="mi">1</span><span class="p">::]]</span>
                <span class="n">init_vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="n">vn</span><span class="p">)</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">val_names</span><span class="p">[</span><span class="mi">1</span><span class="p">::]]</span>

                <span class="n">init_val_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;initial values&quot;</span><span class="p">]</span><span class="o">+</span>\
                               <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">init_vals</span><span class="p">]</span>

                <span class="n">sol_val_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;matched values&quot;</span><span class="p">]</span><span class="o">+</span>\
                              <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol_vals</span><span class="p">]</span>

                <span class="n">pcntd_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="mf">100.0</span><span class="o">*</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">zip_vals</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sol_vals</span><span class="p">,</span> <span class="n">init_vals</span><span class="p">)</span>
                <span class="n">pcntd_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">pcntd_fn</span><span class="p">(</span><span class="n">sval</span><span class="p">,</span> <span class="n">ival</span><span class="p">)</span> <span class="k">for</span> <span class="n">sval</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">zip_vals</span><span class="p">]</span>
                <span class="n">percent_diff_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">% d</span><span class="s2">ifference&quot;</span><span class="p">]</span><span class="o">+</span>\
                                   <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pcntd</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">%&quot;</span> <span class="k">for</span> <span class="n">pcntd</span> <span class="ow">in</span> <span class="n">pcntd_vals</span><span class="p">]</span>

                <span class="n">output_table</span> <span class="o">=</span> <span class="p">[</span><span class="n">val_names</span><span class="p">,</span> <span class="n">init_val_str</span><span class="p">,</span> <span class="n">sol_val_str</span><span class="p">,</span>
                                <span class="n">percent_diff_str</span><span class="p">]</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matching completed for&quot;</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="s2">&quot;star!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">output_table</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">row_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">))</span>

            <span class="c1"># failed match</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Matching was unsuccessful for star with properties: </span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s1">&#39;mass = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">mass</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;log_R = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">log_R</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;center_he4 = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">center_he4</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;surface_he4 = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">surface_he4</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;surface_h1 = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">surface_h1</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;he_core_mass = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">he_core_mass</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, &#39;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;center_c12 = </span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">center_c12</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

            <span class="c1"># done with matching attempts</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">DIVIDER_STR</span><span class="p">)</span>

        <span class="n">match_m0</span> <span class="o">=</span> <span class="n">match_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">match_t0</span> <span class="o">=</span> <span class="n">match_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">match_m0</span><span class="p">,</span> <span class="n">match_t0</span></div>


<div class="viewcode-block" id="TrackMatcher.match_through_root">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.match_through_root">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match_through_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">get_root0</span><span class="p">,</span> <span class="n">get_track_val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Match the star through a root method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            This is a SingleStar object, typically representing</span>
<span class="sd">            a member of a binary star system that we are trying</span>
<span class="sd">            to match to a single star track.</span>

<span class="sd">        get_root0 : function</span>
<span class="sd">            Function that is used to get an initial guess for a</span>
<span class="sd">            closely matching stellar track.</span>

<span class="sd">        get_track_val : function</span>
<span class="sd">            Function that returns a single value of a stellar property</span>
<span class="sd">            from the interpolated time-series along a requested stellar</span>
<span class="sd">            track of mass `m0` at an age of `t`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        match_vals : array</span>
<span class="sd">            Mass and age of the star found through matching. These serve</span>
<span class="sd">            as starting points for subsequent (post-match) evolution.</span>

<span class="sd">        best_sol : OptimizeResult object</span>
<span class="sd">            The OptimizeResult object that contains attributes of the</span>
<span class="sd">            closest matching stellar track. Produced by SciPy&#39;s `root()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">htrack</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span>

        <span class="c1"># if the star can be considered an HMS star</span>
        <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_HMS_MATCHING</span><span class="p">:</span>

            <span class="c1"># get initial guess for matching via search for closest track</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">get_root0</span><span class="p">([</span><span class="s2">&quot;center_h1&quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">star</span><span class="o">.</span><span class="n">center_h1</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span><span class="p">],</span>
                            <span class="n">htrack</span><span class="p">,</span> <span class="n">rescale_facs</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>

            <span class="c1"># Using modified Powell method to find match starting</span>
            <span class="c1"># from time series from above (in x0) using difference</span>
            <span class="c1"># of center X and stellar mass to find match</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span>
                                    <span class="n">get_track_val</span><span class="p">(</span><span class="s2">&quot;center_h1&quot;</span><span class="p">,</span>
                                                    <span class="n">htrack</span><span class="p">,</span>
                                                    <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">star</span><span class="o">.</span><span class="n">center_h1</span><span class="p">,</span>
                                    <span class="n">get_track_val</span><span class="p">(</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span>
                                                    <span class="n">htrack</span><span class="p">,</span>
                                                    <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span>
                                    <span class="p">],</span>
                        <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;hybr&quot;</span>
                        <span class="p">)</span>

        <span class="c1"># or if not an HMS star</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># same as above but using He core mass and total mass</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">get_root0</span><span class="p">(</span>
                            <span class="p">[</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">star</span><span class="o">.</span><span class="n">he_core_mass</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span><span class="p">],</span>
                            <span class="n">htrack</span><span class="p">,</span>
                            <span class="n">rescale_facs</span><span class="o">=</span><span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">300</span><span class="p">]</span>
                            <span class="p">)</span>

            <span class="n">sol</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span>
                                    <span class="n">get_track_val</span><span class="p">(</span><span class="s2">&quot;he_core_mass&quot;</span><span class="p">,</span>
                                                    <span class="n">htrack</span><span class="p">,</span>
                                                    <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">star</span><span class="o">.</span><span class="n">he_core_mass</span><span class="p">,</span>
                                    <span class="n">get_track_val</span><span class="p">(</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span>
                                                    <span class="n">htrack</span><span class="p">,</span>
                                                    <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span><span class="p">],</span>
                        <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;hybr&quot;</span>
                        <span class="p">)</span>

        <span class="c1"># if optimizer failed for some reason set solution as NaN</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span> <span class="ow">or</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">match_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match_vals</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">x</span>

        <span class="k">return</span> <span class="n">match_vals</span><span class="p">,</span> <span class="n">sol</span></div>


<div class="viewcode-block" id="TrackMatcher.match_through_minimize">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.match_through_minimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match_through_minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">get_root0</span><span class="p">,</span> <span class="n">get_track_val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Match the star through a minimization method. An initial</span>
<span class="sd">        match is found using the `get_root0()` function. Then, those</span>
<span class="sd">        initial values are used in SciPy&#39;s minimize method to find</span>
<span class="sd">        the closest matching point in evolution, based on several</span>
<span class="sd">        physical matching metrics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            This is a SingleStar object, typically representing</span>
<span class="sd">            a member of a binary star system that we are trying</span>
<span class="sd">            to match to a single star track.</span>

<span class="sd">        get_root0 : function</span>
<span class="sd">            Function that is used to get an initial guess for a</span>
<span class="sd">            closely matching stellar track.</span>

<span class="sd">        get_track_val : function</span>
<span class="sd">            Function that returns a single value of a stellar property</span>
<span class="sd">            from the interpolated time-series along a requested stellar</span>
<span class="sd">            track of mass `m0` at an age of `t`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        match_vals : array</span>
<span class="sd">            Mass and age of the star found through matching. These serve</span>
<span class="sd">            as starting points for subsequent (post-match) evolution.</span>

<span class="sd">        best_sol : OptimizeResult object</span>
<span class="sd">            The OptimizeResult object that contains attributes of the</span>
<span class="sd">            closest matching stellar track. Produced by SciPy&#39;s `minimize()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># START SUBFUNCTION DEFIITIONS</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_attr_values</span><span class="p">(</span><span class="n">attr_names</span><span class="p">):</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Given a set of attribute names, gets attribute values</span>
<span class="sd">            from a given SingleStar object. These values correspond</span>
<span class="sd">            to the last evolution step of the SingleStar object.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            attr_names : list[str]</span>
<span class="sd">                This list contains strings that are the names of</span>
<span class="sd">                data columns (attributes) to be used as matching</span>
<span class="sd">                metrics.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            attr_values : list[float]</span>
<span class="sd">                This is a list of the values associated with the</span>
<span class="sd">                provided attribute names at the last evolution</span>
<span class="sd">                step experienced by `star`.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">attr_values</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">:</span>
                <span class="n">attr_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">attr_values</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">square_difference</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">,</span> <span class="n">attr_vals</span><span class="p">,</span>
                              <span class="n">attr_scalers</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Compute the square difference between values along a single</span>
<span class="sd">            star evolution track and a given set of values. To find a &#39;good</span>
<span class="sd">            match&#39;, between the given values and the single star track, we</span>
<span class="sd">            ultimately seek to minimize these differences. This is the function</span>
<span class="sd">            used by the minimization algoritms when using matching_method =</span>
<span class="sd">            `minimize`. The minimize function passes values of mass and age</span>
<span class="sd">            that are used to search either the H-rich or He-rich single star</span>
<span class="sd">            grid tracks for a match.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            x : list[float]</span>
<span class="sd">                Contains a mass and time. These are used to get the square</span>
<span class="sd">                difference between a track of that mass at that time and</span>
<span class="sd">                the given star values from prior evolution.</span>

<span class="sd">            new_htrack : bool</span>
<span class="sd">                Set True to search the single star H-rich grids, or False to</span>
<span class="sd">                search the He-rich grids. This is determined primarily</span>
<span class="sd">                through the current `match_type`.</span>

<span class="sd">            attr_names : list[str]</span>
<span class="sd">                Names of SingleStar object attributes that this will calculate</span>
<span class="sd">                the square differences of.</span>

<span class="sd">            attr_vals : list[float]</span>
<span class="sd">                Associated values of provided SingleStar object attribute names.</span>
<span class="sd">                These values should correspond to the prior point in evolution</span>
<span class="sd">                to which we are finding the stellar track match.</span>

<span class="sd">            scalers : list[DataScaler object]</span>
<span class="sd">                DataScaler objects that have been trained previously. These are</span>
<span class="sd">                used to scale given star attributes to the range (0, 1).</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            result : float</span>
<span class="sd">                The square difference between a single star track with mass and</span>
<span class="sd">                age taken from `x` and the given attributes of a SingleStar</span>
<span class="sd">                object.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">zip_attr_props</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr_names</span><span class="p">,</span> <span class="n">attr_vals</span><span class="p">,</span> <span class="n">attr_scalers</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">star_val</span><span class="p">,</span> <span class="n">attr_scaler</span> <span class="ow">in</span> <span class="n">zip_attr_props</span><span class="p">:</span>

                <span class="c1"># get interpolated attribute value from grid at</span>
                <span class="c1"># proposed x (m0, t) values</span>
                <span class="c1"># TODO: can this be sped up? w/o this call,</span>
                <span class="c1">#       execution time lowers by a factor of 100</span>
                <span class="n">grid_track_val</span> <span class="o">=</span> <span class="n">get_track_val</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># scale values</span>
                <span class="n">scaled_grid_track_val</span> <span class="o">=</span> <span class="n">attr_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">grid_track_val</span><span class="p">)</span>
                <span class="n">scaled_star_val</span> <span class="o">=</span> <span class="n">attr_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">star_val</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">MATCHING_WITH_RELATIVE_DIFFERENCE</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">((</span><span class="n">scaled_grid_track_val</span> <span class="o">-</span> <span class="n">scaled_star_val</span><span class="p">)</span>
                            <span class="o">/</span> <span class="n">scaled_star_val</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">scaled_grid_track_val</span> <span class="o">-</span> <span class="n">scaled_star_val</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_attr_props</span><span class="p">(</span><span class="n">new_htrack</span><span class="p">,</span> <span class="n">list_for_matching</span><span class="p">):</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">               This unpacks a list_for_matching which has the following</span>
<span class="sd">            structure:</span>

<span class="sd">                list_for_matching = [[matching attr. names], [rescale_factors],</span>
<span class="sd">                                    [scaling method], [mass_bnds], [age_bnds]]</span>

<span class="sd">               This also trains DataScaler objects for each provided matching</span>
<span class="sd">            attribute, such that the values are scaled to the range (0, 1).</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            new_htrack : bool</span>
<span class="sd">                Set True to search the single star H-rich grids, or False to</span>
<span class="sd">                search the He-rich grids. This is determined primarily</span>
<span class="sd">                through the current `match_type`.</span>

<span class="sd">            list_for_matching : list</span>
<span class="sd">                This is a list that contains sublists of types, str, float,</span>
<span class="sd">                str, float, float. The first sublist holds the names for</span>
<span class="sd">                star attributes that will be used to quantify a match. The</span>
<span class="sd">                second holds rescaling factors for those attributes. The</span>
<span class="sd">                third holds DataScaler scaling methods (see</span>
<span class="sd">                posydon.interpolation.data_scaling.DataScaler.fit() for more).</span>
<span class="sd">                The fourth and fifth hold bounds for the minimization</span>
<span class="sd">                algorithms on the stellar mass and age.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            match_attr_names : list[str]</span>
<span class="sd">                The names of the attributes that will be used for matching.</span>
<span class="sd">                These should be SingleStar STARPROPERTIES keys.</span>

<span class="sd">            rescale_facs : list[float]</span>
<span class="sd">                Contains normalization factors to be used for rescaling match</span>
<span class="sd">                attribtue values. This should be the same length as</span>
<span class="sd">                match_attr_names.</span>

<span class="sd">            bnds : list[list[float], list[float]]</span>
<span class="sd">                Lower and upper bounds on initial stellar mass and age to be</span>
<span class="sd">                used in minimization algorithms.</span>

<span class="sd">            scalers : list[DataScaler object]</span>
<span class="sd">                DataScaler objects for each attribute, trained to rescale</span>
<span class="sd">                quantities to the range (0, 1).</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">match_attr_names</span> <span class="o">=</span> <span class="n">list_for_matching</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rescale_facs</span> <span class="o">=</span> <span class="n">list_for_matching</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">scaler_methods</span> <span class="o">=</span> <span class="n">list_for_matching</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bnds</span> <span class="o">=</span> <span class="n">list_for_matching</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Matching parameters and their normalizations:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                      <span class="n">match_attr_names</span><span class="p">,</span> <span class="n">rescale_facs</span><span class="p">)</span>

            <span class="c1"># get (or train and get) scalers for attributes</span>
            <span class="c1"># attributes are scaled to range (0, 1)</span>
            <span class="n">scalers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">match_attr_names</span><span class="p">,</span> <span class="n">scaler_methods</span><span class="p">):</span>
                <span class="c1"># check that attributes are allowed as matching attributes</span>
                <span class="k">if</span> <span class="n">attr_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Expected matching attribute &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> not &quot;</span>
                                         <span class="s2">&quot;added in root_keys list: &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root_keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># create attribute scalers</span>
                <span class="n">scaler_of_attribute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="n">scalers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaler_of_attribute</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">match_attr_names</span><span class="p">,</span> <span class="n">rescale_facs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">scalers</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_match_attrs</span><span class="p">(</span><span class="n">match_type</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">match_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Gather the attribute names and values for matching</span>
<span class="sd">            a given star, plus the attribute bounds and scalings.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            match_type : str</span>
<span class="sd">                A string that sets which matching list to use when obtaining</span>
<span class="sd">                attributes. The defined options are:</span>

<span class="sd">                    &quot;default&quot; :     This gets the set default list of</span>
<span class="sd">                                    attributes, which are dependent on the</span>
<span class="sd">                                    star&#39;s evolutionary state.</span>

<span class="sd">                    &quot;alt&quot; :         This selects alternate lists of attributes</span>
<span class="sd">                                    that are meant to ease the match finding</span>
<span class="sd">                                    process, ignoring certain parameters like</span>
<span class="sd">                                    stellar radius.</span>

<span class="sd">                    &quot;alt_evolved&quot; : This switches the grids that are searched</span>
<span class="sd">                                    for a match for evolved stars, meaning</span>
<span class="sd">                                    post-MS and stripped He stars as a last</span>
<span class="sd">                                    ditch effort to find a match.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            match_attrs : tuple(list[str], list[float])</span>
<span class="sd">                A tuple that contains the match_attr_names, which are the</span>
<span class="sd">                data column names of the match attributes and the</span>
<span class="sd">                match_attr_vals, which are the associated values.</span>

<span class="sd">            scls_bnds : tuple(float, float, DataScaler)</span>
<span class="sd">                A tuple that contains the associated rescaling factors,</span>
<span class="sd">                boundaries, and DataScaler objects of the matching</span>
<span class="sd">                attributes.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># set matching metrics based on star state</span>
            <span class="n">new_htrack</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span>
            <span class="k">if</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_HMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_Hestar_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postHeMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2"> invalid for matching step&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;alt&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(Now trying to match with alternative parameters)&quot;</span><span class="p">)</span>

                <span class="c1"># set alternative matching metrics based on star state</span>
                <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_HMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HMS_alternative</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS_alternative</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_Hestar_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar_alternative</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postHeMS_MATCHING</span><span class="p">:</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS_alternative</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">star</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2"> invalid for matching step&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;evolved_alt&quot;</span><span class="p">:</span>
                <span class="n">Pwarn</span><span class="p">(</span><span class="s2">&quot;Attempting to match an He-star with an H-rich grid or &quot;</span> \
                      <span class="s2">&quot;post-MS star with a stripped-He grid&quot;</span><span class="p">,</span><span class="s2">&quot;EvolutionWarning&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_HMS_MATCHING</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We cannot use match_type=</span><span class="si">{</span><span class="n">match_type</span><span class="si">}</span><span class="s2"> &quot;</span> \
                                <span class="s2">&quot;since star is on the MS. Skipping...&quot;</span><span class="p">)</span>
                    <span class="n">match_ok</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">match_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span><span class="p">)</span>
                    <span class="n">scls_bnds</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">match_attrs</span><span class="p">,</span> <span class="n">scls_bnds</span>

                <span class="c1"># if he star, try matching to H-rich grid</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_Hestar_MATCHING</span><span class="p">:</span>
                    <span class="n">new_htrack</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_HeStar</span>

                <span class="c1"># if post MS star, try matching to He-rich grid</span>
                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postMS_MATCHING</span><span class="p">:</span>
                    <span class="n">new_htrack</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postMS</span>

                <span class="k">elif</span> <span class="n">star</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_FOR_postHeMS_MATCHING</span><span class="p">:</span>
                    <span class="n">new_htrack</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_for_matching_postHeMS</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">POSYDONError</span><span class="p">(</span><span class="s2">&quot;In getting match attributes, match_type &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">match_type</span><span class="si">}</span><span class="s2">&#39; is not a recognized option. Please &quot;</span>
                        <span class="s2">&quot;check how this happened and either create a new &quot;</span>
                        <span class="s2">&quot;option in get_match_attrs() or correct it.&quot;</span><span class="p">)</span>

            <span class="c1"># have approriate matching list, now get necessary attr properties</span>
            <span class="n">attr_names</span><span class="p">,</span> <span class="n">rescl_facs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">sclrs</span> <span class="o">=</span> <span class="n">get_attr_props</span><span class="p">(</span><span class="n">new_htrack</span><span class="p">,</span>
                                                                 <span class="n">match_list</span><span class="p">)</span>
            <span class="n">attr_vals</span> <span class="o">=</span> <span class="n">get_attr_values</span><span class="p">(</span><span class="n">attr_names</span><span class="p">)</span>

            <span class="n">match_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_names</span><span class="p">,</span> <span class="n">attr_vals</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span><span class="p">)</span>
            <span class="n">scls_bnds</span> <span class="o">=</span> <span class="p">(</span><span class="n">rescl_facs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">sclrs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">match_attrs</span><span class="p">,</span> <span class="n">scls_bnds</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_match_params</span><span class="p">(</span><span class="n">match_type</span><span class="p">,</span> <span class="n">match_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Get initial guess for minimization and matching specs.</span>
<span class="sd">            The initial guess is found via the `get_root0()` function (see</span>
<span class="sd">            that function for further details). The other specs gathered</span>
<span class="sd">            by this function are the function arguments needed for the</span>
<span class="sd">            square_difference function matching attribute boundaries</span>
<span class="sd">            used by SciPy&#39;s minimization function.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            match_type :str</span>
<span class="sd">                This string sets the type of matching to be done. This can</span>
<span class="sd">                be &#39;default&#39;, &#39;alt&#39;, or &#39;alt_evolved&#39;. This string will</span>
<span class="sd">                dictate which matching parameters to use when considering</span>
<span class="sd">                which stellar track is the closest match. (See</span>
<span class="sd">                get_match_attrs() for more details.)</span>

<span class="sd">            match_ok : bool</span>
<span class="sd">                This boolean tracks whether something went wrong or not. If</span>
<span class="sd">                this is False, the matching is considered failed and will</span>
<span class="sd">                abort.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            x0 : list[float]</span>
<span class="sd">                A list that contains the initial stellar mass and age of a</span>
<span class="sd">                stellar track. Used as an initial guess for</span>
<span class="sd">                `scipy.optimize.minimize()`.</span>

<span class="sd">            fnc_args : tuple(bool, list[str], list[float], list[DataScaler])</span>
<span class="sd">                This tuple contains the arguments that will be passed to the</span>
<span class="sd">                minimization function. The minimization function uses the</span>
<span class="sd">                square_difference function. See that function for more details.</span>

<span class="sd">            bnds : list[float]</span>
<span class="sd">                Lower and upper bounds on initial stellar mass and age to be</span>
<span class="sd">                used in minimization algorithms.</span>

<span class="sd">            match_ok : bool</span>
<span class="sd">                This boolean tracks whether something went wrong or not. If</span>
<span class="sd">                this is False, the matching is considered failed and will</span>
<span class="sd">                abort.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># get names, values, bounds, and scalings of</span>
            <span class="c1"># attributes to be matched</span>
            <span class="n">match_attrs</span><span class="p">,</span> <span class="n">scls_bnds</span> <span class="o">=</span> <span class="n">get_match_attrs</span><span class="p">(</span><span class="n">match_type</span><span class="p">,</span>
                                                     <span class="n">match_ok</span><span class="o">=</span><span class="n">match_ok</span><span class="p">)</span>

            <span class="c1"># unpack matching properties</span>
            <span class="n">match_attr_names</span><span class="p">,</span> <span class="n">match_attr_vals</span> <span class="o">=</span> <span class="n">match_attrs</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span> <span class="o">=</span> <span class="n">match_attrs</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">rescale_facs</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">scalers</span> <span class="o">=</span> <span class="n">scls_bnds</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">match_ok</span><span class="p">:</span>
                <span class="n">fnc_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_htrack</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fnc_args</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">match_ok</span>

            <span class="c1"># Get closest matching point along track single star grids. x0</span>
            <span class="c1"># contains the corresponding initial guess for mass and age</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">get_root0</span><span class="p">(</span><span class="n">match_attr_names</span><span class="p">,</span> <span class="n">match_attr_vals</span><span class="p">,</span>
                           <span class="n">new_htrack</span><span class="p">,</span> <span class="n">rescale_facs</span><span class="o">=</span><span class="n">rescale_facs</span><span class="p">)</span>
            <span class="n">fnc_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_attr_names</span><span class="p">,</span> <span class="n">match_attr_vals</span><span class="p">,</span> <span class="n">scalers</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">fnc_args</span><span class="p">,</span> <span class="n">bnds</span><span class="p">,</span> <span class="n">match_ok</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">do_minimization</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;TNC&#39;</span><span class="p">,</span> <span class="n">match_type</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform minimization procedure with a given method and</span>
<span class="sd">            match type, using SciPy&#39;s minimize function.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            method : str</span>
<span class="sd">               This sets the desired solver to be used by SciPy&#39;s minimize</span>
<span class="sd">               function. The default is &#39;TNC&#39;, but we also use &#39;Powell&#39; as</span>
<span class="sd">               an alternative.</span>

<span class="sd">            match_type :str</span>
<span class="sd">                This string sets the type of matching to be done. This can</span>
<span class="sd">                be &#39;default&#39;, &#39;alt&#39;, or &#39;alt_evolved&#39;. This string will</span>
<span class="sd">                dictate which matching parameters to use when considering</span>
<span class="sd">                which stellar track is the closest match. (See</span>
<span class="sd">                get_match_attrs() for more details.)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            sol : OptimizeResult object</span>
<span class="sd">                This is the OptimizeResult object returned by SciPy&#39;s</span>
<span class="sd">                minimize function. It contains the mass and age of the</span>
<span class="sd">                closest matching stellar track, found through</span>
<span class="sd">                minimization.</span>

<span class="sd">            new_htrack : bool</span>
<span class="sd">                This boolean tracks whether the star should be matched to</span>
<span class="sd">                the H- or He-rich single star grid. This can change in the</span>
<span class="sd">                match finding process.</span>

<span class="sd">            match_ok : bool</span>
<span class="sd">                This boolean tracks whether something went wrong or not. If</span>
<span class="sd">                this is False, the matching is considered failed and will</span>
<span class="sd">                abort.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">x0</span><span class="p">,</span> <span class="n">fnc_args</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">match_ok</span> <span class="o">=</span> <span class="n">get_match_params</span><span class="p">(</span><span class="n">match_type</span><span class="p">)</span>
            <span class="n">new_htrack</span> <span class="o">=</span> <span class="n">fnc_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">match_ok</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">failed_sol</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span>

            <span class="c1"># Powell&#39;s method does not work with bound in SciPy version &lt; 1.5.x</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Powell&#39;</span> <span class="ow">and</span> <span class="n">SCIPY_VER</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring bounds because method = </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;does not accept them in SciPy v</span><span class="si">{</span><span class="n">SCIPY_VER</span><span class="si">}</span><span class="s2">.x.&quot;</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Run minimization method</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Minimize sq, Euclidean dist. w/ Newton&#39;s method (TNC)</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">square_difference</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">fnc_args</span><span class="p">,</span>
                                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

                <span class="c1"># guard against NaN solutions, ensuring they will fail</span>
                <span class="n">sol</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="mf">1e99</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span> <span class="k">else</span> <span class="n">sol</span><span class="o">.</span><span class="n">fun</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching attempt completed:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best solution: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(tol = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance</span><span class="si">}</span><span class="s2">)&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sol.success = </span><span class="si">{</span><span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NumericalError</span><span class="p">(</span><span class="s2">&quot;SciPy numerical differentiation &quot;</span>
                                        <span class="s2">&quot;occurred outside boundary while &quot;</span>
                                        <span class="s2">&quot;matching to single star track&quot;</span><span class="p">)</span>

            <span class="c1"># check for failures:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching result: FAILED&quot;</span>
                            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reason: Solution exceeds tolerance &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span><span class="si">}</span><span class="s2"> &gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">match_ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching result: FAILED&quot;</span>
                            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reason: Optimizer failed (sol.success = &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sol</span><span class="o">.</span><span class="n">success</span><span class="si">}</span><span class="s2">)&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Optimizer termination reason: </span><span class="si">{</span><span class="n">sol</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">match_ok</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">match_ok</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Matching result: OK&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span>

        <span class="c1"># END SUBFUNCTION DEFIITIONS</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">DIVIDER_STR</span><span class="p">)</span>

        <span class="c1"># defined sequence of matching attempt types and methods</span>
        <span class="n">match_sequence</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;TNC&quot;</span><span class="p">},</span>
                            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;Powell&quot;</span><span class="p">},</span>
                            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;alt&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;TNC&quot;</span><span class="p">},</span>
                            <span class="mi">4</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;evolved_alt&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;TNC&quot;</span><span class="p">}</span>
                            <span class="p">}</span>

        <span class="c1"># dummy</span>
        <span class="n">failed_sol</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>
        <span class="n">failed_sol</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">failed_sol</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="mf">1e99</span>
        <span class="n">failed_sol</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;This is a dummy SciPy OptimizeResult object.&quot;</span>

        <span class="n">best_sol</span> <span class="o">=</span> <span class="n">failed_sol</span>
        <span class="k">for</span> <span class="n">attempt_num</span> <span class="ow">in</span> <span class="n">match_sequence</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="n">match_type</span> <span class="o">=</span> <span class="n">match_sequence</span><span class="p">[</span><span class="n">attempt_num</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">match_sequence</span><span class="p">[</span><span class="n">attempt_num</span><span class="p">][</span><span class="s2">&quot;method&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matching attempt </span><span class="si">{</span><span class="n">attempt_num</span><span class="si">}</span><span class="s2"> started...&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_type = </span><span class="si">{</span><span class="n">match_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;method = </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">sol</span><span class="p">,</span> <span class="n">new_htrack</span><span class="p">,</span> <span class="n">match_ok</span> <span class="o">=</span> <span class="n">do_minimization</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">match_type</span><span class="p">)</span>

            <span class="n">better_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
            <span class="n">sol_is_better</span> <span class="o">=</span>  <span class="n">better_match</span> <span class="ow">and</span> <span class="n">sol</span><span class="o">.</span><span class="n">success</span>
            <span class="c1"># TODO: case for nan solution</span>
            <span class="c1"># if a better solution is found, update it</span>
            <span class="k">if</span> <span class="n">sol_is_better</span><span class="p">:</span>
                <span class="n">star</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">new_htrack</span>
                <span class="n">best_sol</span> <span class="o">=</span> <span class="n">sol</span>

            <span class="c1"># if we matched successfully and solution was better, we&#39;re done</span>
            <span class="k">if</span> <span class="n">sol_is_better</span> <span class="ow">and</span> <span class="n">match_ok</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># if matching is still not successful, set result to NaN:</span>
        <span class="n">exceeds_tol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exceeds_tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">best_sol</span><span class="o">.</span><span class="n">success</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final matching result: FAILED&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span><span class="p">):</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reason: Solution exceeds hard tolerance &quot;</span><span class="o">+</span>\
                           <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span><span class="si">}</span><span class="s2"> &gt; &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">best_sol</span><span class="o">.</span><span class="n">success</span><span class="p">):</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reason: Optimizer failed, &quot;</span>
                           <span class="s2">&quot;sol.success = </span><span class="si">{best_sol.success}</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Optimizer termination reason: &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">best_sol</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">match_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

        <span class="c1"># or else we found a solution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final matching result: SUCCESS&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best solution within hard tolerance: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_sol</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span><span class="si">:</span><span class="s2">.8f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">matching_tolerance_hard</span><span class="p">)</span>

            <span class="n">match_vals</span> <span class="o">=</span> <span class="n">best_sol</span><span class="o">.</span><span class="n">x</span>

        <span class="k">return</span> <span class="n">match_vals</span><span class="p">,</span> <span class="n">best_sol</span></div>



<div class="viewcode-block" id="TrackMatcher.get_star_match_data">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.get_star_match_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_star_match_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span>
                            <span class="n">copy_prev_m0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy_prev_t0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Match a given component of a binary (i.e., a star) to a</span>
<span class="sd">        single star model. This then creates and returns interpolator</span>
<span class="sd">        objects that may be used to calculate properties of the star</span>
<span class="sd">        as a function of time.</span>

<span class="sd">            In the case of a compact object, radius, mdot, and Idot are</span>
<span class="sd">        set to zero. One may use another star, e.g., the companion of</span>
<span class="sd">        the compact object to provide a mass and age.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binary : BinaryStar object</span>
<span class="sd">            A binary star object, containing the binary system&#39;s properties.</span>

<span class="sd">        star : SingleStar object</span>
<span class="sd">            A single star object that contains the star&#39;s properties.</span>

<span class="sd">        copy_prev_m0 : float</span>
<span class="sd">            A mass value that may be copied from another star in the case</span>
<span class="sd">            where the target star is a compact object</span>

<span class="sd">        copy_prev_t0 : float</span>
<span class="sd">            An age value that may be copied from another star in the case</span>
<span class="sd">            where the target star is a compact object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        match_m0 : float</span>
<span class="sd">            Initial mass (in solar units) of the matched model.</span>

<span class="sd">        match_t0 : float</span>
<span class="sd">            Age (in years) of the matched model.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="c1"># get the initial m0, t0 track</span>
            <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
                <span class="n">match_m0</span><span class="p">,</span> <span class="n">match_t0</span> <span class="o">=</span> <span class="n">copy_prev_m0</span><span class="p">,</span> <span class="n">copy_prev_t0</span>
            <span class="k">elif</span> <span class="n">binary</span><span class="o">.</span><span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;ZAMS&#39;</span> <span class="ow">or</span> <span class="n">binary</span><span class="o">.</span><span class="n">event</span> <span class="o">==</span> <span class="s1">&#39;redirect_from_ZAMS&#39;</span><span class="p">:</span>
                <span class="c1"># ZAMS stars in wide (non-mass exchaging binaries) that are</span>
                <span class="c1"># directed to detached step at birth</span>
                <span class="n">match_m0</span><span class="p">,</span> <span class="n">match_t0</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_before_matching</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># matching to single star grids (getting mass, age of</span>
                <span class="c1"># closest track)</span>
                <span class="n">match_m0</span><span class="p">,</span> <span class="n">match_t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_to_single_star</span><span class="p">(</span><span class="n">star</span><span class="p">)</span>
                <span class="n">t_after_matching</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="n">match_tspan</span> <span class="o">=</span> <span class="n">t_after_matching</span><span class="o">-</span><span class="n">t_before_matching</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching duration: </span><span class="si">{</span><span class="n">match_tspan</span><span class="si">:</span><span class="s2">.6g</span><span class="si">}</span><span class="s2"> sec</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># bad result</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">match_m0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">match_t0</span><span class="p">):</span>
            <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>

        <span class="c1"># check if m0 is in the grid bounds</span>
        <span class="n">outside_low</span> <span class="o">=</span> <span class="n">match_m0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">outside_low</span> <span class="o">=</span> <span class="n">outside_low</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span>
        <span class="n">outside_high</span> <span class="o">=</span> <span class="n">match_m0</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid_mass</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">outside_high</span> <span class="o">=</span> <span class="n">outside_high</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span>
        <span class="k">if</span> <span class="n">outside_low</span> <span class="ow">or</span> <span class="n">outside_high</span><span class="p">:</span>
            <span class="n">set_binary_to_failed</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MatchingError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The mass </span><span class="si">{</span><span class="n">match_m0</span><span class="si">}</span><span class="s2"> is out of &quot;</span>
                                <span class="s2">&quot;the single star grid range and &quot;</span>
                                <span class="s2">&quot;cannot be matched to a track.&quot;</span><span class="p">)</span>

        <span class="c1"># get/interpolate track values for requested mass match_m0</span>
        <span class="n">get_track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span>

        <span class="n">max_time</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">max_simulation_time</span>
        <span class="k">assert</span> <span class="n">max_time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;max_time is non-positive&quot;</span>

        <span class="c1"># getting track of mass match_m0&#39;s age data</span>
        <span class="c1"># try/except logic required to avoid errors with compact objects</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_track</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="n">match_m0</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_time</span><span class="p">])</span>

        <span class="c1"># max timelength of the track</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">age</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Getting the other track values</span>
        <span class="c1"># and setting up the interpolator</span>
        <span class="n">kvalue</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># try/except logic required to avoid errors with compact objects</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kvalue</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_track</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">match_m0</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">kvalue</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="c1"># change data types</span>
        <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;inertia&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;inertia&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">msol</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">rsol</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">kvalue</span><span class="p">[</span><span class="s1">&#39;conv_env_turnover_time_l_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kvalue</span><span class="p">[</span><span class="s1">&#39;conv_env_turnover_time_l_b&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span>
        <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;L&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;log_L&quot;</span><span class="p">]</span>
        <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;log_R&quot;</span><span class="p">]</span>

        <span class="c1"># overwrite certain values for compact objects</span>
        <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
            <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span>
            <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;mdot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;mdot&quot;</span><span class="p">])</span>
            <span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;log_R&quot;</span><span class="p">])</span>

        <span class="n">y_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kvalue</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">kvalue</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">y_keys</span><span class="p">]</span>
        <span class="n">positives</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KEYS_POSITIVE</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">y_keys</span><span class="p">]</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">y_keys</span><span class="p">)</span>

        <span class="c1"># Add derivatives where needed</span>
        <span class="k">if</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
            <span class="c1"># for compact objects, set Idot to zero</span>
            <span class="n">y_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;inertia&quot;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kvalue</span><span class="p">[</span><span class="s2">&quot;inertia&quot;</span><span class="p">])</span>

        <span class="n">y_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Idot&quot;</span><span class="p">)</span>
        <span class="n">positives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">derivatives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

        <span class="c1"># validate age data</span>
        <span class="n">i_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i_bad</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: found non-monotonic age data &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;while matching star (m0=</span><span class="si">{</span><span class="n">match_m0</span><span class="si">}</span><span class="s2">). &quot;</span><span class="p">)</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">i_bad</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="n">bad</span><span class="p">)</span>
                <span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">bad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">i_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>

        <span class="n">interp1d</span> <span class="o">=</span> <span class="n">SingleStarInterpolator</span><span class="p">(</span><span class="n">age</span><span class="p">,</span>
                            <span class="n">y_data</span><span class="p">,</span>
                            <span class="n">y_keys</span><span class="p">,</span>
                            <span class="n">positives</span><span class="o">=</span><span class="n">positives</span><span class="p">,</span>
                            <span class="n">derivatives</span><span class="o">=</span><span class="n">derivatives</span><span class="p">)</span>

        <span class="c1"># store additional info in SingleStarInterpolator object</span>
        <span class="n">interp1d</span><span class="o">.</span><span class="n">t_max</span> <span class="o">=</span> <span class="n">t_max</span>
        <span class="n">interp1d</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">max_time</span>
        <span class="n">interp1d</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">match_t0</span>
        <span class="n">interp1d</span><span class="o">.</span><span class="n">m0</span> <span class="o">=</span> <span class="n">match_m0</span>

        <span class="c1"># update star with interp1d object built from matched values</span>
        <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span> <span class="o">=</span> <span class="n">interp1d</span>

        <span class="k">if</span> <span class="n">star</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">star</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">star</span><span class="o">.</span><span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">co</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">match_m0</span><span class="p">,</span> <span class="n">match_t0</span></div>


<div class="viewcode-block" id="TrackMatcher.calc_omega">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.calc_omega">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            Calculate the spin of a star from its (pre-match) moment</span>
<span class="sd">        of inertia and angular momentum (or rotation rates). This is</span>
<span class="sd">        required because we match a rotating model (from the binary grids)</span>
<span class="sd">        to a non-rotating model (from the single star grids).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            Star object containing the star properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        omega_in_rad_per_year: float</span>
<span class="sd">            The rotation rate of the star in radians per year,</span>
<span class="sd">            calculated from the star&#39;s (pre-match) angular momentum</span>
<span class="sd">            and moment of inertia.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        InappropriateValueWarning</span>
<span class="sd">            If the pre-match rotation quantities are NaN or None and can</span>
<span class="sd">            not calculate a the post-match rotation rate, we setting the</span>
<span class="sd">            post-match rotation rate to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log_total_J</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">log_total_angular_momentum</span>
        <span class="n">total_MOI</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">total_moment_of_inertia</span>
        <span class="n">omega_div_omega_c</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">surf_avg_omega_div_omega_crit</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">surf_avg_omega</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">log_total_J</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">total_MOI</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating post-match omega using &quot;</span> \
                      <span class="s2">&quot;pre-match angular momentum and moment of inertia&quot;</span><span class="p">)</span>

            <span class="c1"># the last factor converts rad/s to rad/yr</span>
            <span class="n">omega_in_rad_per_yr</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.0</span> <span class="o">**</span> <span class="n">log_total_J</span>
                                     <span class="o">/</span> <span class="n">total_MOI</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we equate the secondary&#39;s initial omega to surf_avg_omega</span>
            <span class="c1"># (although the critical rotation should be improved to</span>
            <span class="c1"># take into account radiation pressure)</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating post-match omega using &quot;</span> \
                          <span class="s2">&quot;pre-match surf_avg_omega&quot;</span><span class="p">)</span>

                <span class="n">omega_in_rad_per_yr</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span>

            <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">omega_div_omega_c</span><span class="p">):</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating post-match omega using &quot;</span> \
                          <span class="s2">&quot;pre-match surf_avg_omega_div_omega_crit&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">log_R</span><span class="p">):</span>
                    <span class="n">numerator</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">standard_cgrav</span> <span class="o">*</span> <span class="n">star</span><span class="o">.</span><span class="n">mass</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">msol</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.0</span> <span class="o">**</span> <span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">log_R</span><span class="p">)</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">rsol</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
                    <span class="n">omega_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span> <span class="c1"># rad/s</span>
                    <span class="n">omega_c</span> <span class="o">*=</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span> <span class="c1"># rad/yr</span>
                    <span class="n">omega_in_rad_per_yr</span> <span class="o">=</span> <span class="n">omega_div_omega_c</span> <span class="o">*</span> <span class="n">omega_c</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">interp_res</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
                    <span class="n">radius_interp</span> <span class="o">=</span> <span class="n">interp_res</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">]</span>
                    <span class="n">mass_interp</span> <span class="o">=</span> <span class="n">interp_res</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span>
                    <span class="c1">#radius_interp = star.interp1d[&quot;R&quot;](star.interp1d[&quot;t0&quot;])</span>
                    <span class="c1">#mass_interp = star.interp1d[&quot;mass&quot;](star.interp1d[&quot;t0&quot;])</span>

                    <span class="n">numerator</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">standard_cgrav</span> <span class="o">*</span> <span class="n">mass_interp</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">msol</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">radius_interp</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">rsol</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span>
                    <span class="n">omega_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span> <span class="c1"># rad/s</span>
                    <span class="n">omega_c</span> <span class="o">*=</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span> <span class="c1"># rad/yr</span>
                    <span class="n">omega_in_rad_per_yr</span> <span class="o">=</span> <span class="n">omega_div_omega_c</span> <span class="o">*</span> <span class="n">omega_c</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">omega_in_rad_per_yr</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not calculate post-match omega, &quot;</span> \
                          <span class="s2">&quot;pre-match values are None or NaN.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pre-match rotation rates:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;surf_avg_omega = &quot;</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;surf_avg_omega_div_omega_crit = &quot;</span><span class="p">,</span>
                          <span class="n">omega_div_omega_c</span><span class="p">)</span>
                    <span class="n">Pwarn</span><span class="p">(</span><span class="s2">&quot;Setting (post-match) rotation rate to zero.&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;InappropriateValueWarning&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">omega</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">omega_in_rad_per_yr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pre-match omega [rad/yr] = &quot;</span><span class="p">,</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculated omega [rad/yr] = &quot;</span><span class="p">,</span> <span class="n">omega_in_rad_per_yr</span><span class="p">)</span>
            <span class="n">pcdiff</span> <span class="o">=</span> <span class="mf">100.0</span><span class="o">*</span><span class="p">(</span><span class="n">omega_in_rad_per_yr</span><span class="o">-</span><span class="n">omega</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span><span class="p">)</span> \
                                                <span class="o">/</span> <span class="n">omega_in_rad_per_yr</span>
            <span class="n">omega_percent_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">pcdiff</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;omega [rad/yr] </span><span class="si">% d</span><span class="s2">ifference = &quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">omega_percent_diff</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">omega_in_rad_per_yr</span></div>


<div class="viewcode-block" id="TrackMatcher.update_rotation_info">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.update_rotation_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_rotation_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Once we have matched to a non-rotating single star, we need to</span>
<span class="sd">        calculate what the single star&#39;s spin should be, based the star&#39;s</span>
<span class="sd">        rotation before matching. This calculates a new rotation rate for the</span>
<span class="sd">        matched star from the previous moment of inertia and angular</span>
<span class="sd">        momentum (or rotation rate in lieu of those). This also updates the</span>
<span class="sd">        stars in the binary with the newly calculated values to reflect this.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        primary: SingleStar object</span>
<span class="sd">            A single star object, representing the primary (more evolved) star</span>
<span class="sd">            in the binary and containing its properties.</span>

<span class="sd">        secondary: SingleStar object</span>
<span class="sd">            A single star object, representing the secondary (less evolved)</span>
<span class="sd">            star in the binary and containing its properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        omega0_pri: float</span>
<span class="sd">            The rotation rate of the primary star in radians per year,</span>
<span class="sd">            calculated from the star&#39;s (pre-match) angular momentum</span>
<span class="sd">            and moment of inertia.</span>

<span class="sd">        omega0_sec: float</span>
<span class="sd">            The rotation rate of the secondary star in radians per year,</span>
<span class="sd">            calculated from the star&#39;s (pre-match) angular momentum</span>
<span class="sd">            and moment of inertia.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega0_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_omega</span><span class="p">(</span><span class="n">secondary</span><span class="p">)</span>

        <span class="c1"># recalculate rotation quantities using the newly calculated</span>
        <span class="c1"># omega [rad/s] here. Need to be careful about case where</span>
        <span class="c1"># omega was made/is 0 to avoid div by zero errors or None * float</span>
        <span class="n">surf_avg_omega</span> <span class="o">=</span> <span class="n">secondary</span><span class="o">.</span><span class="n">surf_avg_omega</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">surf_avg_omega</span><span class="p">)</span> <span class="ow">and</span> <span class="n">surf_avg_omega</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">new_omega</span> <span class="o">=</span> <span class="n">omega0_sec</span> <span class="o">/</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span> <span class="c1"># rad/s</span>
            <span class="n">old_ratio</span> <span class="o">=</span> <span class="n">secondary</span><span class="o">.</span><span class="n">surf_avg_omega_div_omega_crit</span>
            <span class="n">old_omega</span> <span class="o">=</span> <span class="n">surf_avg_omega</span>
            <span class="n">old_omega_c</span> <span class="o">=</span> <span class="n">old_omega</span> <span class="o">/</span> <span class="n">old_ratio</span>
            <span class="n">new_ratio</span> <span class="o">=</span> <span class="n">new_omega</span> <span class="o">/</span> <span class="n">old_omega_c</span>
            <span class="n">new_lgJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">new_omega</span> <span class="o">*</span> <span class="n">secondary</span><span class="o">.</span><span class="n">total_moment_of_inertia</span><span class="p">)</span>
            <span class="n">old_lgJ</span> <span class="o">=</span> <span class="n">secondary</span><span class="o">.</span><span class="n">log_total_angular_momentum</span>
            <span class="k">if</span> <span class="n">secondary</span><span class="o">.</span><span class="n">matched</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega_div_omega_crit&quot;</span><span class="p">,</span> <span class="n">new_ratio</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega&quot;</span><span class="p">,</span> <span class="n">new_omega</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;log_total_angular_momentum&quot;</span><span class="p">,</span> <span class="n">new_lgJ</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega_div_omega_crit&quot;</span><span class="p">,</span> <span class="n">old_ratio</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega&quot;</span><span class="p">,</span> <span class="n">old_omega</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="s2">&quot;log_total_angular_momentum&quot;</span><span class="p">,</span> <span class="n">old_lgJ</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">surf_avg_omega_div_omega_crit</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">surf_avg_omega</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">log_total_angular_momentum</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_normal</span><span class="p">:</span>
            <span class="n">omega0_pri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_omega</span><span class="p">(</span><span class="n">primary</span><span class="p">)</span>

            <span class="n">surf_avg_omega</span> <span class="o">=</span> <span class="n">primary</span><span class="o">.</span><span class="n">surf_avg_omega</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">surf_avg_omega</span><span class="p">)</span> <span class="ow">and</span> <span class="n">surf_avg_omega</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">new_omega</span> <span class="o">=</span> <span class="n">omega0_pri</span> <span class="o">/</span> <span class="n">const</span><span class="o">.</span><span class="n">secyer</span> <span class="c1"># rad/s</span>
                <span class="n">old_ratio</span> <span class="o">=</span> <span class="n">primary</span><span class="o">.</span><span class="n">surf_avg_omega_div_omega_crit</span>
                <span class="n">old_omega</span> <span class="o">=</span> <span class="n">surf_avg_omega</span>
                <span class="n">old_omega_c</span> <span class="o">=</span> <span class="n">old_omega</span> <span class="o">/</span> <span class="n">old_ratio</span>
                <span class="n">new_ratio</span> <span class="o">=</span> <span class="n">new_omega</span> <span class="o">/</span> <span class="n">old_omega_c</span>
                <span class="n">new_lgJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">new_omega</span> <span class="o">*</span> <span class="n">primary</span><span class="o">.</span><span class="n">total_moment_of_inertia</span><span class="p">)</span>
                <span class="n">old_lgJ</span> <span class="o">=</span> <span class="n">primary</span><span class="o">.</span><span class="n">log_total_angular_momentum</span>
                <span class="k">if</span> <span class="n">primary</span><span class="o">.</span><span class="n">matched</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega_div_omega_crit&quot;</span><span class="p">,</span> <span class="n">new_ratio</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega&quot;</span><span class="p">,</span> <span class="n">new_omega</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;log_total_angular_momentum&quot;</span><span class="p">,</span> <span class="n">new_lgJ</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega_div_omega_crit&quot;</span><span class="p">,</span> <span class="n">old_ratio</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;surf_avg_omega&quot;</span><span class="p">,</span> <span class="n">old_omega</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s2">&quot;log_total_angular_momentum&quot;</span><span class="p">,</span> <span class="n">old_lgJ</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">surf_avg_omega_div_omega_crit</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">surf_avg_omega</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">log_total_angular_momentum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># omega of compact objects or massless remnant</span>
            <span class="c1"># (won&#39;t be used for integration)</span>
            <span class="n">omega0_pri</span> <span class="o">=</span> <span class="n">omega0_sec</span>


        <span class="k">return</span> <span class="n">omega0_pri</span><span class="p">,</span> <span class="n">omega0_sec</span></div>


<div class="viewcode-block" id="TrackMatcher.do_matching">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.do_matching">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">step_name</span><span class="o">=</span><span class="s2">&quot;step_match&quot;</span><span class="p">,</span>
                    <span class="n">match_secondary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">match_primary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform binary to single star grid matching. This is currently</span>
<span class="sd">        used when transitioning to detached star evolution from binary but</span>
<span class="sd">        may be used in other steps. This performs several actions:</span>

<span class="sd">            a. Determines which star is primary/secondary in the evolution</span>
<span class="sd">               and their evolutionary states. If evolvable, matching will</span>
<span class="sd">               proceed.</span>
<span class="sd">            b. Match either one or both stars to a (non-rotating) single</span>
<span class="sd">               star evolution track.</span>
<span class="sd">            c. Calculate the matched star&#39;s rotation using the pre-match</span>
<span class="sd">               step&#39;s angular momentum-related properties.</span>
<span class="sd">            d. Returns the primary/secondary stars with interpolator</span>
<span class="sd">               objects that may be used to calculate quantities along the</span>
<span class="sd">               time series of each star for further evolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binary : BinaryStar object</span>
<span class="sd">            A binary star object, containing the binary system&#39;s properties.</span>

<span class="sd">        step_name : str</span>
<span class="sd">            If self.record_matching is True, then the matched quantities of</span>
<span class="sd">            the star will be appended to the history. This is a string that</span>
<span class="sd">            can be used as a custom label in the BinaryStar object&#39;s history,</span>
<span class="sd">            meant to indicate the relevant evolution step&#39;s name. This should</span>
<span class="sd">            normally match the name of the step in which the matching was</span>
<span class="sd">            made, e.g., &quot;step_detached&quot;.</span>

<span class="sd">        match_secondary : bool</span>
<span class="sd">            A boolean that indicates whether to perform matching on star 1.</span>

<span class="sd">        match_primary : bool</span>
<span class="sd">            A boolean that indicates whether to perform matching on star 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primary_out : tuple(SingleStar, PchipInterpolator, float)</span>
<span class="sd">            The first element is the SingleStar object of the primary</span>
<span class="sd">            (more evolved) star. The second element is the primary&#39;s</span>
<span class="sd">            PchipInterpolator object, used to interpolate values along</span>
<span class="sd">            this star&#39;s time series. The third is the primary&#39;s</span>
<span class="sd">            calculated (post-match) rotation rate, using angular</span>
<span class="sd">            momentum-related quantites from the pre-match step.</span>

<span class="sd">        secondary_out :  tuple(SingleStar, PchipInterpolator, float)</span>
<span class="sd">            The first element is the SingleStar object of the secondary</span>
<span class="sd">            (less evolved) star. The second element is the secondary&#39;s</span>
<span class="sd">            PchipInterpolator object, used to interpolate values along</span>
<span class="sd">            this star&#39;s time series. The third is the secondary&#39;s</span>
<span class="sd">            calculated (post-match) rotation rate, using angular</span>
<span class="sd">            momentum-related quantites from the pre-match step.</span>

<span class="sd">        only_CO : bool</span>
<span class="sd">            A boolean indicating whether the binary system contains only a</span>
<span class="sd">            single compact object (True) or not (False). As in the detached</span>
<span class="sd">            step, it may be desirable to use this flag to exit an evolution</span>
<span class="sd">            step, as a single compact obejct (point mass) can not be evolved</span>
<span class="sd">            further.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the `primary_normal` and `primary_not_normal` flags are</span>
<span class="sd">            both determined to be False. One or the other should be True.</span>

<span class="sd">        MatchingError</span>
<span class="sd">            If the stellar matching to a single star model fails, or the</span>
<span class="sd">            PchipInterpolator object returned from matching is None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># determine star states for matching</span>
        <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">only_CO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_star_states</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>

        <span class="c1">#if only_CO:</span>
        <span class="c1">#    return binary.star_1, binary.star_2, only_CO</span>

        <span class="c1"># record which star we performed matching on for reporting purposes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_secondary</span> <span class="o">=</span> <span class="n">match_secondary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_primary</span> <span class="o">=</span> <span class="n">match_primary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">primary</span><span class="o">.</span><span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">secondary</span><span class="o">.</span><span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># primary is a CO or massless remnant, or else it is &quot;normal&quot;</span>
        <span class="c1"># TODO: should these be star properties? also, do we only really need one?</span>
        <span class="n">has_non_existent</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">all_exist</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_not_normal</span> <span class="o">=</span> <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="ow">or</span> <span class="n">has_non_existent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_normal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="ow">and</span> <span class="n">all_exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_not_normal</span> <span class="o">=</span> <span class="n">secondary</span><span class="o">.</span><span class="n">co</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondary_normal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">secondary</span><span class="o">.</span><span class="n">co</span>

        <span class="c1"># get the matched data of binary components</span>
        <span class="c1"># match secondary:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_secondary</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matching secondary star (state = </span><span class="si">{</span><span class="n">secondary</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondary_not_normal</span><span class="p">:</span>
                <span class="n">m0</span><span class="p">,</span> <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_star_match_data</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span>
                                        <span class="n">copy_prev_m0</span> <span class="o">=</span> <span class="n">secondary</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                                        <span class="n">copy_prev_t0</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondary_normal</span><span class="p">:</span>
                <span class="n">m0</span><span class="p">,</span> <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_star_match_data</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">)</span>
                <span class="c1"># record which star got matched</span>
                <span class="k">if</span> <span class="n">secondary</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">secondary</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;During matching, the secondary should either be &quot;</span>
                                <span class="s2">&quot;normal (stellar object) or &quot;</span>
                                <span class="s2">&quot;not normal (a CO or nonexistent companion).&quot;</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">secondary.co = </span><span class="si">{</span><span class="n">secondary</span><span class="o">.</span><span class="n">co</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">non_existent_companion = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">companion_1_exists = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">companion_1_exists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">companion_2_exists = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">companion_2_exists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_primary</span><span class="p">:</span>
            <span class="c1"># match primary</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matching primary star (state = </span><span class="si">{</span><span class="n">primary</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_not_normal</span><span class="p">:</span>
                <span class="c1"># copy the secondary star except mass which is of the primary,</span>
                <span class="c1"># and radius, mdot, Idot = 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_star_match_data</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">primary</span><span class="p">,</span>
                                        <span class="n">copy_prev_m0</span> <span class="o">=</span> <span class="n">m0</span><span class="p">,</span>
                                        <span class="n">copy_prev_t0</span> <span class="o">=</span> <span class="n">t0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_normal</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">get_star_match_data</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">primary</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">primary</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">primary</span> <span class="o">==</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primary_normal</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_not_normal</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;During matching, the primary should either be &quot;</span>
                                <span class="s2">&quot;normal (stellar object) or &quot;</span>
                                <span class="s2">&quot;not normal (a CO or nonexistent companion).&quot;</span><span class="p">,</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">primary.co = </span><span class="si">{</span><span class="n">primary</span><span class="o">.</span><span class="n">co</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">non_existent_companion = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">companion_1_exists = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">companion_1_exists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">companion_2_exists = &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">companion_2_exists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">secondary</span><span class="o">.</span><span class="n">interp1d</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_secondary</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">primary</span><span class="o">.</span><span class="n">interp1d</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_primary</span><span class="p">):</span>
            <span class="n">failed_state</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">state</span>
            <span class="n">set_binary_to_failed</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">MatchingError</span><span class="p">(</span><span class="s2">&quot;Grid matching failed for &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">failed_state</span><span class="si">}</span><span class="s2"> binary. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">secondary.interp1d = </span><span class="si">{</span><span class="n">secondary</span><span class="o">.</span><span class="n">interp1d</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">primary.interp1d = </span><span class="si">{</span><span class="n">primary</span><span class="o">.</span><span class="n">interp1d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># recalculate rotation quantities after matching</span>
        <span class="n">omega0_pri</span><span class="p">,</span> <span class="n">omega0_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_rotation_info</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">)</span>

        <span class="c1"># update binary history with matched values</span>
        <span class="c1"># (only shown in history if record_matching = True)</span>
        <span class="c1"># (this gets overwritten after detached evolution)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondary_normal</span> <span class="ow">and</span> <span class="n">secondary</span><span class="o">.</span><span class="n">matched</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_star_properties</span><span class="p">(</span><span class="n">secondary</span><span class="p">,</span> <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_normal</span> <span class="ow">and</span> <span class="n">primary</span><span class="o">.</span><span class="n">matched</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_star_properties</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_matching</span><span class="p">:</span>
            <span class="c1"># append matching information as a part of step_detached</span>
            <span class="n">binary</span><span class="o">.</span><span class="n">step_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span><span class="p">:</span>
                <span class="n">binary</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="s2">&quot;Match12&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_s1</span><span class="p">:</span>
                <span class="n">binary</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="s2">&quot;Match1&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_s2</span><span class="p">:</span>
                <span class="n">binary</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="s2">&quot;Match2&quot;</span>

            <span class="n">binary</span><span class="o">.</span><span class="n">append_state</span><span class="p">()</span>

        <span class="n">primary</span><span class="o">.</span><span class="n">omega0</span> <span class="o">=</span> <span class="n">omega0_pri</span>
        <span class="n">secondary</span><span class="o">.</span><span class="n">omega0</span> <span class="o">=</span> <span class="n">omega0_sec</span>

        <span class="k">return</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">only_CO</span></div>


<div class="viewcode-block" id="TrackMatcher.determine_star_states">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.determine_star_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_star_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Determines which star is primary (further evolved) and which is</span>
<span class="sd">        secondary (less evolved). Determines whether stars should be</span>
<span class="sd">        matched to the H- or He-rich grid, whether they exist, or if they</span>
<span class="sd">        are compact objects/massless remnants. This is used to determine</span>
<span class="sd">        how to match the stars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        binary: BinaryStar object</span>
<span class="sd">            A binary star object, containing the binary system&#39;s properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primary : SingleStar object</span>
<span class="sd">            A single star object, representing the primary (more evolved) star</span>
<span class="sd">            in the binary and containing its properties.</span>

<span class="sd">        secondary : SingleStar object</span>
<span class="sd">            A single star object, representing the secondary (less evolved)</span>
<span class="sd">            star in the binary and containing its properties.</span>

<span class="sd">        only_CO : bool</span>
<span class="sd">            A boolean indicating whether the binary system contains only a</span>
<span class="sd">            single compact object (True) or not (False). As in the detached</span>
<span class="sd">            step, it may be desirable to use this flag to exit an evolution</span>
<span class="sd">            step, as a single compact obejct (point mass) can not be evolved</span>
<span class="sd">            further.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        POSYDONError</span>
<span class="sd">            If there is no star to evolve (both are massless remnants), then</span>
<span class="sd">            evolution can no continue and detached step should not have been</span>
<span class="sd">            called.</span>

<span class="sd">        ValueError</span>
<span class="sd">            If the State of star 1 or 2 is not recognized.</span>

<span class="sd">        POSYDONError</span>
<span class="sd">            If the `non_existent_companion` of the binary is determined to</span>
<span class="sd">            be not equal to 0 (both stars exist), 1 (only star 2 exists),</span>
<span class="sd">            or 2 (only star 1 exists), something has gone wrong.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">only_CO</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># update BinaryStar instance with attributes storing whether star 1/2</span>
        <span class="c1"># exists or not</span>
        <span class="n">binary</span><span class="o">.</span><span class="n">check_who_exists</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">POSYDONError</span><span class="p">(</span><span class="s2">&quot;There is no star to evolve. Who summoned me?&quot;</span><span class="p">)</span>

        <span class="c1"># where both stars exist. The primary is a potential compact object, or</span>
        <span class="c1"># the more evolved star</span>
        <span class="n">s_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">binary</span><span class="o">.</span><span class="n">star_1</span><span class="p">,</span> <span class="n">binary</span><span class="o">.</span><span class="n">star_2</span><span class="p">])</span>
        <span class="n">s_CO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_CO</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_arr</span><span class="p">])</span>
        <span class="n">s_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_H_RICH</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_arr</span><span class="p">])</span>
        <span class="n">s_He</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="n">STAR_STATES_HE_RICH</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_arr</span><span class="p">])</span>
        <span class="n">s_massless</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;massless_remnant&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_arr</span><span class="p">])</span>
        <span class="n">s_valid</span> <span class="o">=</span> <span class="n">s_H</span> <span class="o">|</span> <span class="n">s_He</span> <span class="o">|</span> <span class="n">s_CO</span> <span class="o">|</span> <span class="n">s_massless</span>    <span class="c1"># states considered here</span>
        <span class="n">s_htrack</span> <span class="o">=</span> <span class="n">s_H</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">s_CO</span><span class="p">)</span>   <span class="c1"># only true if h rich and not a CO</span>

        <span class="c1"># check if star states are recognizable</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="o">~</span><span class="n">s_valid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Star1 state: </span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">star_1</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(valid: </span><span class="si">{</span><span class="n">s_valid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Star2 state: </span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">star_2</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(valid: </span><span class="si">{</span><span class="n">s_valid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># both stars exist, detached step of a binary</span>

            <span class="c1"># states match, either both H stars or both He stars and not any COs</span>
            <span class="c1"># prevents He+CO going into here.</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">s_valid</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">s_htrack</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">s_htrack</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">s_CO</span><span class="p">))):</span>
                <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># states mismatch, one is an H star and the other is an He star</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">s_valid</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">s_CO</span><span class="p">)):</span>
                <span class="n">htrack_mask</span> <span class="o">=</span> <span class="n">s_htrack</span> <span class="o">==</span> <span class="kc">True</span>

                <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="o">~</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="o">~</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="o">~</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

                <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="n">htrack_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="c1"># states mismatch, one is a CO and other is an H or He star</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">s_valid</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">s_CO</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">s_CO</span><span class="p">))):</span>
                <span class="n">CO_mask</span> <span class="o">=</span> <span class="n">s_CO</span> <span class="o">==</span> <span class="kc">True</span>

                <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="o">~</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

                <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="o">~</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="o">~</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="o">~</span><span class="n">CO_mask</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># both stars are compact objects</span>
                <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># In case a star is a massless remnant:</span>
        <span class="c1"># We force primary.co = True for all isolated evolution</span>
        <span class="c1"># where the primary does not exist (is a massless remnant)</span>
        <span class="c1"># and the secondary is the one evolving</span>

        <span class="c1"># star 1 is a massless remnant, only star 2 exists</span>
        <span class="k">elif</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># massless remnant</span>
            <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">secondary</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
                <span class="n">only_CO</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">only_CO</span>

        <span class="c1"># star 2 is a massless remnant, only star 1 exists</span>
        <span class="k">elif</span> <span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">primary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">primary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">primary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">secondary</span> <span class="o">=</span> <span class="n">s_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">htrack</span> <span class="o">=</span> <span class="n">s_htrack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">secondary</span><span class="o">.</span><span class="n">co</span> <span class="o">=</span> <span class="n">s_CO</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">secondary</span><span class="o">.</span><span class="n">co</span><span class="p">:</span>
                <span class="n">only_CO</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">only_CO</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">POSYDONError</span><span class="p">(</span><span class="s2">&quot;non_existent_companion = &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">binary</span><span class="o">.</span><span class="n">non_existent_companion</span><span class="si">}</span><span class="s2"> (should be -1, 0, 1, or 2).&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">only_CO</span></div>


<div class="viewcode-block" id="TrackMatcher.update_star_properties">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.update_star_properties">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_star_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">htrack</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This updates a SingleStar object (`star`) with the</span>
<span class="sd">        values from a single star track that has initial mass `m0`</span>
<span class="sd">        and age `t0`. This can be used after matching finds the</span>
<span class="sd">        closest `m0`, `t0` to update the SingleStar object with the</span>
<span class="sd">        values of the best matching single star track. This will</span>
<span class="sd">        not update the `log_total_angular_momentum` or</span>
<span class="sd">        `surf_avg_omega` because the single star track is non-rotating</span>
<span class="sd">        and those quantities are poorly defined.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            A single star object that contains the star&#39;s properties.</span>

<span class="sd">        htrack : bool</span>
<span class="sd">            A boolean that specifies whether the star would be found in the</span>
<span class="sd">            hydrogen rich single star grid or not (in which case it is</span>
<span class="sd">            matched to the helium rich single star grid).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initial mass and age at point of closest match</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="o">.</span><span class="n">m0</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="o">.</span><span class="n">t0</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KEYS</span><span class="p">:</span>

            <span class="c1"># skip updating rotation rate quantities because</span>
            <span class="c1"># they&#39;re 0 or not defined in non-rotating tracks</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;log_total_angular_momentum&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;surf_avg_omega&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_track_val</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">htrack</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">new_val</span><span class="p">)</span></div>



<div class="viewcode-block" id="TrackMatcher.get_star_final_values">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.get_star_final_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_star_final_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This updates the final values of a SingleStar object,</span>
<span class="sd">        given an initial stellar mass `m0`, typically found from</span>
<span class="sd">        matching to a single star track.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            A single star object that contains the star&#39;s properties.</span>

<span class="sd">        htrack : bool</span>
<span class="sd">            A boolean that specifies whether the star would be found in the</span>
<span class="sd">            hydrogen rich single star grid or not (in which case it is</span>
<span class="sd">            matched to the helium rich single star grid).</span>

<span class="sd">        m0 : float</span>
<span class="sd">            Initial stellar mass (in solar units) of the single star track</span>
<span class="sd">            that we will grab values from and update `star` with.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m0</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="o">.</span><span class="n">m0</span>
        <span class="n">htrack</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span> <span class="k">if</span> <span class="n">htrack</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>
        <span class="n">get_final_values</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_final_values</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_keys</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">get_final_values</span><span class="p">(</span><span class="s1">&#39;S1_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">m0</span><span class="p">))</span></div>


<div class="viewcode-block" id="TrackMatcher.get_star_profile">
<a class="viewcode-back" href="../../../../api_reference/posydon.binary_evol.DT.html#posydon.binary_evol.DT.track_match.TrackMatcher.get_star_profile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_star_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This updates the stellar profile of a SingleStar object,</span>
<span class="sd">        given an initial stellar mass `m0`, typically found from</span>
<span class="sd">        matching to a single star track. The profile of the SingleStar</span>
<span class="sd">        object is updated to become the profile of the (matched) single</span>
<span class="sd">        star track.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        star : SingleStar object</span>
<span class="sd">            A single star object that contains the star&#39;s properties.</span>

<span class="sd">        htrack : bool</span>
<span class="sd">            A boolean that specifies whether the star would be found in the</span>
<span class="sd">            hydrogen rich single star grid or not (in which case it is</span>
<span class="sd">            matched to the helium rich single star grid).</span>

<span class="sd">        m0 : float</span>
<span class="sd">            Initial stellar mass (in solar units) of the single star track</span>
<span class="sd">            that we will grab values from and update `star` with.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m0</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">interp1d</span><span class="o">.</span><span class="n">m0</span>
        <span class="n">htrack</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">htrack</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Hrich</span> <span class="k">if</span> <span class="n">htrack</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_strippedHe</span>
        <span class="n">get_profile</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">get_profile</span>
        <span class="n">profile_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_profile</span><span class="p">(</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="n">m0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_keys</span><span class="p">:</span>
            <span class="n">profile_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_profile</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">profile_new</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">surf_avg_omega</span>

        <span class="n">star</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile_new</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Tassos Fragos.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      Version: 2.2.4
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        
        <dl>
            <dt> v2</dt>
            
            <dd><a href="https://posydon.org/POSYDON/v2.0.6/index.html">2.0</a></dd>
            
            <dd><a href="https://posydon.org/POSYDON/v2.1.7/index.html">2.1</a></dd>
            
            <dd><a href="https://posydon.org/POSYDON/v2.2.4/index.html">2.2</a></dd>
            
        </dl>
        
        <dl>
            <dt> v1</dt>
            
            <dd><a href="https://posydon.org/POSYDON/v1.0.5/index.html">1.0</a></dd>
            
        </dl>
        
    </div>
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>