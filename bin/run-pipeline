'''

MESA low_res_grids were run.

STEP 1: grid slice creation (PARALLELISED)

grid_type, metallicity, grid_slices, compression
'HMS-HMS', '1e-01_Zsun', LITE/ORIGINAL
['grid_low_res_0','grid_low_res_1','grid_low_res_2',
'grid_low_res_3','grid_low_res_4','grid_low_res_5',
'grid_random_1'] ---> output *.h5

STEP 2: grid concatenation
[['grid_low_res_0','grid_low_res_1','grid_low_res_2',
'grid_low_res_3','grid_low_res_4','grid_low_res_5']] -->
grid_low_res_combined

STEP 3: plot grid slices
---> loop all plot types
---> chek failure rate

STEP 4: rerun grid with fix A
grid_low_res_combined.rerun(index=logic) --> grid_rerun_1/grid.csv
                                        --> grid_random_1_rerun_1/grid.csv
---- MEN/WOMEN POWER will run reruns ----

call STEP 1: ['grid_rerun_1','grid_random_1_rerun_1',] --> *.h5
call STEP 2: [['grid_low_res_combined','grid_rerun_1'],
              ['grid_random_1','grid_random_rerun_1']]
              ---> gird_low_res_combined_rerun_1.h5
                   grid_random_1_rerun_1.h5
call STEP 3: rerun grid with fix B
........ --> grid_rerun_2/grid.csv, call STEP 1, 2.. 3

STEP 5:
do post processing on the ORIGINAL grids and append back on
LITE/ORIGINAL for both grid_low_res_combined_rerun_N and grid_random_1_rerun_N

STEP 6:
train interpolators


I NEED TO REGENERATE THE GRIDS AFTER A PR

STEP 1:
'HMS-HMS', '1e-01_Zsun', LITE/ORIGINAL
['grid_low_res_0','grid_low_res_1','grid_low_res_2',
'grid_low_res_3','grid_low_res_4','grid_low_res_5',
'grid_random_1','grid_low_res_rerun_1', 'grid_low_res_rerun_2',
'grid_low_res_rerun_3']
STEP 2:
[
['grid_low_res_0','grid_low_res_1','grid_low_res_2',
'grid_low_res_3','grid_low_res_4','grid_low_res_5'], --> grid_low_combined.h5
['grid_low_combined','grid_low_res_rerun_1'], ---> grid_low_res_combined_rerun_1.h5
['grid_low_res_combined_rerun_1','grid_rerun_2'], ---> grid_low_res_combined_rerun_2.h5
['grid_low_res_combined_rerun_2','grid_rerun_3'], ---> grid_low_res_combined_rerun_3.h5
['grid_low_random_1','grid_random_1_rerun_1'], ---> grid_low_res_combined_rerun_1.h5
['grid_low_random_1_rerun_1','grid_random_1_rerun_2'], ---> grid_low_res_combined_rerun_2.h5
['grid_low_random_1_rerun_2','grid_random_1_rerun_3'], ---> grid_low_res_combined_rerun_3.h5
]


'''

import os
import sys
import pickle
import numpy as np
import pandas as pd
from shutil import copyfile
from collections import Counter
from posydon.grids.psygrid import (PSyGrid,
                                   join_grids,
                                   DEFAULT_HISTORY_DS_EXCLUDE,
                                   DEFAULT_PROFILE_DS_EXCLUDE,
                                   EXTRA_COLS_DS_EXCLUDE)
from posydon.grids.post_processing import (post_process_grid,
                                           add_post_processed_quantities)
from posydon.interpolation.IF_interpolation import IFInterpolator



def create_grid_slice(i, step_1="step_1.csv", verbose=False):

    df = pd.read_csv(os.path.join(PATH, step_1))
    grid_path = df.loc[i,'path_to_grid']
    compression = df.loc[i,'compression']

    grid_name = grid_path.split('/')[-1]
    grid_output = os.path.join('/',os.path.join(*grid_path.split('/')[:-1]),
                                            compression,grid_name+'.h5')
    if verbose:
        print('processing ', grid_path)
        print('saving file ',  grid_output)

    if compression == 'ORIGINAL':
        history_DS_error = None
        profile_DS_error = None
        profile_DS_interval = None
        history_DS_exclude = DEFAULT_HISTORY_DS_EXCLUDE
        profile_DS_exclude = DEFAULT_PROFILE_DS_EXCLUDE
    elif compression == 'LITE':
        history_DS_error = 0.1
        profile_DS_error = 0.1
        profile_DS_interval = -0.005
        history_DS_exclude = EXTRA_COLS_DS_EXCLUDE
        profile_DS_exclude = EXTRA_COLS_DS_EXCLUDE
    else:
        raise ValueError('compression = %s not supported!'%compression)

    grid = PSyGrid(verbose=True)
    grid.create(grid_path,
                grid_output,
                overwrite=True,
                history_DS_error=history_DS_error,
                profile_DS_error=profile_DS_error,
                history_DS_exclude=history_DS_exclude,
                profile_DS_exclude=profile_DS_exclude,
                profile_DS_interval=profile_DS_interval,
                compression="gzip9",
                start_at_RLO=False,
                initial_RLO_fix=True)
    grid.close()


def combine_grid_slices(step_2="step_2.csv", verbose=False):

    df = pd.read_csv(os.path.join(PATH, step_2))

    for grid_combined_key in df.keys():
        gird_names = df[grid_combined_key].to_list()
        if verbose:
            print('Combinining: ', gird_names)
            print('into:', grid_combined_key)
        join_grids(gird_names, grid_combined_key)


def plot_grid(i, step_3="step_3.csv", verbose=False):

    df = pd.read_csv(os.path.join(PATH, step_3))
    grid_path = df.loc[i,'path_to_grid']
    plot_dir = df.loc[i,'path_to_plot']
    grid = PSyGrid(verbose=False)
    grid.load(grid_path)

    # TODO: mk plot directories
    # dirname = 'plots/'+str(sys.argv[1])+'/'
    # dirs=['plots/', dirname,
    #       dirname+'TF12/',dirname+'TF1/',dirname+'TF2/',dirname+'TF3/',dirname+'TF4/',
    #       dirname+'debug_mt/',dirname+'debug_rl_1/',dirname+'debug_rl_2/']
    # for dir_ in dirs:
    #     if not os.path.isdir(path.replace(version,'')+dir_):
    #         os.mkdir(dir_)

    if 'HMS-HMS' in grid_path:
        # mass ratio slices
        qs = np.linspace(0.05,1.,20)
        qs[-1] = 0.99

        for q in qs.tolist():
            # TODO: skip plotting slice if there are no data
            try:
                PLOT_PROPERTIES = {
                    'figsize' : (4,3.5),
                    'path_to_file' : os.path.join(plot_dir,'TF12/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)}
                }

                grid.plot2D('star_1_mass', 'period_days', None,
                             termination_flag='combined_TF12',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,5),
                    'path_to_file' : os.path.join(plot_dir,'TF1/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'zmin' : -8,
                    'zmax' : -1,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)},
                    'colorbar': {'pad': 0.12}
                }

                grid.plot2D('star_1_mass', 'period_days', 'lg_mtransfer_rate',
                             termination_flag='termination_flag_1',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,3.5),
                    'path_to_file' : os.path.join(plot_dir,'TF2/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)}
                }

                grid.plot2D('star_1_mass', 'period_days', None,
                             termination_flag='termination_flag_2',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,3.5),
                    'path_to_file' : os.path.join(plot_dir,'TF3/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)}
                }

                grid.plot2D('star_1_mass', 'period_days', None,
                             termination_flag='termination_flag_3',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,3.5),
                    'path_to_file' : os.path.join(plot_dir,'TF4/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)}
                }

                grid.plot2D('star_1_mass', 'period_days', None,
                             termination_flag='termination_flag_4',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,5),
                    'path_to_file' : os.path.join(plot_dir,'debug_rl_1/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'zmin' : -0.5,
                    'zmax' : 0.5,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)},
                    'colorbar': {'pad': 0.12}
                }

                grid.plot2D('star_1_mass', 'period_days', 'rl_relative_overflow_1',
                             termination_flag='debug',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,5),
                    'path_to_file' : os.path.join(plot_dir,'debug_rl_2/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'zmin' : -0.5,
                    'zmax' : 0.5,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)},
                    'colorbar': {'pad': 0.12}
                }

                grid.plot2D('star_1_mass', 'period_days', 'rl_relative_overflow_2',
                             termination_flag='debug',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)

                PLOT_PROPERTIES = {
                    'figsize' : (4,5),
                    'path_to_file' : os.path.join(plot_dir,'debug_mt/'),
                    'show_fig' : False,
                    'fname' : 'grid_q_%1.2f.png'%q,
                    'title' : '$q=%1.2f$'%q,
                    'log10_x' : True,
                    'log10_y' : True,
                    'zmin' : -8,
                    'zmax' : -1,
                    'legend2D' : {'bbox_to_anchor' : (1.03, 0.5)},
                    'colorbar': {'pad': 0.12}
                }

                grid.plot2D('star_1_mass', 'period_days', 'lg_mtransfer_rate',
                             termination_flag='debug',
                             grid_3D=True, slice_3D_var_str='mass_ratio',
                             slice_3D_var_range=(q-2.5e-2,q+2.5e-2),
                             verbose=False, **PLOT_PROPERTIES)
            except Exception as e:
                print('FAILED TO PLOT q=%s!'%q)
                print('')
                print(e)
                continue

def check_failure_rate(i, step_3="step_3.csv", verbose=False):

    df = pd.read_csv(os.path.join(PATH, step_3))
    grid_path = df.loc[i,'path_to_grid']
    plot_dir = df.loc[i,'path_to_plot']
    grid = PSyGrid(verbose=False)
    grid.load(grid_path)

    count = Counter(grid.final_values['interpolation_class'])
    n = 0.
    for key in count.keys():
        n += count[key]
    print('Failure rate', round(count['not_converged']/n*100,2),'%')


def post_processing(i, step_4="step_4.csv", verbose=False):

    df = pd.read_csv(os.path.join(PATH, step_4))
    grid_path = df.loc[i,'path_to_grid']
    processed_grid_path = df.loc[i,'path_to_processed_grid']
    grid = PSyGrid(verbose=False)
    grid.load(grid_path)

    if verbose:
        print('Compute process quantities ...')
    if "CO" in grid_path:
        star_2_CO = True
    else:
        star_2_CO = False
    grid_ORIGINAL = PSyGrid(grid_path.replace('LITE','ORIGINAL'))
    MESA_dirs_EXTRA_COLUMNS, EXTRA_COLUMNS = post_process_grid(grid_ORIGINAL,
                                                               index=None,
                                                               star_2_CO=star_2_CO,
                                                               verbose=verbose)


    # post processed quantities are appended to the grid object, hence
    # we create a copy of it and append back to it
    if os.path.exists(processed_grid_path):
        if verbose:
            print('Post processed grid file alredy exist, removing it...')
        os.remove(processed_grid_path)
    copyfile(grid_path, processed_grid_path)

    if verbose:
        print('Add process quantities to grid...')
    grid_LITE = PSyGrid(processed_grid_path)
    add_post_processed_quantities(grid_LITE, MESA_dirs_EXTRA_COLUMNS,
                                  EXTRA_COLUMNS, verbose=verbose)
    grid_LITE.close()


def train_interpolators(i, step_5="step_5.csv", verbose=False):)

    df = pd.read_csv(os.path.join(PATH, step_5))
    grid_path = df.loc[i,'path_to_grid']
    interpolator_path = df.loc[i,'path_to_interpolator']
    grid = PSyGrid(verbose=False)
    grid.load(grid_path)

    grid = PSyGrid(grid_train)

    second = ['S1_direct_f_fb', 'S1_direct_mass', 'S1_direct_spin']
    third = ['S1_Fryer+12-rapid_f_fb', 'S1_Fryer+12-rapid_mass', 'S1_Fryer+12-rapid_spin']
    fourth = ['S1_Fryer+12-delayed_f_fb', 'S1_Fryer+12-delayed_mass', 'S1_Fryer+12-delayed_spin']
    fifth = ['S1_Sukhbold+16-engineN20_f_fb', 'S1_Sukhbold+16-engineN20_mass', 'S1_Sukhbold+16-engineN20_spin']
    sixth = ['S1_Patton&Sukhbold20-engineN20_f_fb', 'S1_Patton&Sukhbold20-engineN20_mass', 'S1_Patton&Sukhbold20-engineN20_spin']


    first = [key for key in grid.final_values.dtype.names
    if key != "model_number"
    and (type(grid.final_values[key][0]) != np.str_)
    and any(~np.isnan(grid.final_values[key]))]

    for sec in second:
        first.remove(sec)

    for thrd in third:
        first.remove(thrd)

    for frth in fourth:
        first.remove(frth)

    for ffth in fifth:
        first.remove(ffth)

    for sxth in sixth:
        first.remove(sxth)

    # TODO: train CC2 quantities coming from reverse MT systems
    interp = IFInterpolator(grid=grid, interpolators = [
        {
            "interp_method": [method, method, method],
            "interp_classes": ["no_MT", "stable_MT", "unstable_MT"],
            "out_keys": first,
            "class_method": "kNN",
            "c_keys": ["interpolation_class", 'S1_state', 'S2_state',
                       # Collapse quantities
                       'S1_direct_SN_type', 'S1_Fryer+12-rapid_SN_type',
                       'S1_Fryer+12-delayed_SN_type', 'S1_Sukhbold+16-engineN20_SN_type',
                       'S1_Patton&Sukhbold20-engineN20_SN_type',
                       # v1 POSYDON does not have S2 reaching CC before S1
                       # all these classifier map to None
                       'S2_direct_state', 'S2_Fryer+12-rapid_state',
                       'S2_Fryer+12-delayed_state', 'S2_Sukhbold+16-engineN20_state',
                       'S2_Patton&Sukhbold20-engineN20_state',
                       'S2_direct_SN_type', 'S2_Fryer+12-rapid_SN_type',
                       'S2_Fryer+12-delayed_SN_type', 'S2_Sukhbold+16-engineN20_SN_type',
                       'S2_Patton&Sukhbold20-engineN20_SN_type'
                      ],
            "c_key": "interpolation_class"
        },
        {
            "interp_method": [method, method, method],
            "interp_classes": ["BH", "WD", "NS"],
            "out_keys": second,
            "class_method": "kNN",
            "c_keys": ['S1_direct_state'],
            "c_key": 'S1_direct_state'
        },
        {
            "interp_method": [method, method, method],
            "interp_classes": ["BH", "WD", "NS"],
            "out_keys": third,
            "class_method": "kNN",
            "c_keys": ['S1_Fryer+12-rapid_state'],
            "c_key": 'S1_Fryer+12-rapid_state'
        },
        {
            "interp_method": [method, method, method],
            "interp_classes": ["BH", "WD", "NS"],
            "out_keys": fourth,
            "class_method": "kNN",
            "c_keys": ['S1_Fryer+12-delayed_state'],
            "c_key": 'S1_Fryer+12-delayed_state'
        },
        {
            "interp_method": [method, method, method],
            "interp_classes": ["BH", "WD", "NS"],
            "out_keys": fifth,
            "class_method": "kNN",
            "c_keys": ['S1_Sukhbold+16-engineN20_state'],
            "c_key": 'S1_Sukhbold+16-engineN20_state'
        },
        {
            "interp_method": [method, method, method],
            "interp_classes": ["BH", "WD", "NS"],
            "out_keys": sixth,
            "class_method": "kNN",
            "c_keys": ['S1_Patton&Sukhbold20-engineN20_state'],
            "c_key": 'S1_Patton&Sukhbold20-engineN20_state'
        }
    ])

     # training and saving
    interp.train()
    interp.save(interpolator_path)


def export_dataset():
    # this fucntion should copy all the files to a directory
    # for POSYDON pop synth
    pass


if __name__ == '__main__':

    PATH_TO_GRIDS = '/projects/b1119/POSYDON_GRIDS/'
    PATH = '.'
    VERBOSE = True

    # JOB ARRAY
    CREATE_GRID_SLICES = False
    if CREATE_GRID_SLICES:
        # chose grid slice given the slurm jobarray index
        i = int(sys.argv[1])
        create_grid_slice(i, verbose=VERBOSE)

    # SINGLE JOB
    # TODO: make LITE/ORIGINAL version parallel with a JOB ARRAY
    COMBINE_GRID_SLICES = False
    if COMBINE_GRID_SLICES:
        combine_grid_slices(verbose=VERBOSE)

    # JOB ARRAY
    PLOT_GRIDS = False
    if PLOT_GRIDS:
        i = int(sys.argv[1])
        plot_grid(i, verbose=VERBOSE)

    # JOB ARRAY
    CHECK_FAILURE_RATE = False
    if CHECK_FAILURE_RATE:
        i = int(sys.argv[1])
        check_failure_rate(i, verbose=VERBOSE)

    # JOB ARRAY
    POST_PROCESSING = True
    if POST_PROCESSING:
        i = int(sys.argv[1])
        post_processing(i, verbose=VERBOSE)

    # JOB ARRAY
    TRAIN_INTERPOLATORS = True
    if TRAIN_INTERPOLATORS:
        i = int(sys.argv[1])
        train_interpolators(i, verbose=VERBOSE)

    # SINGLE JOB
    # train_interpolators()

# python pipleline.py
